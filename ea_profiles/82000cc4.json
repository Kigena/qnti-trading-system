{
  "name": "StormTiger D1-100",
  "magic_number": 12345,
  "symbols": [
    "GET",
    "RVI",
    "MACD"
  ],
  "timeframes": [
    "D1"
  ],
  "parameters": {
    "Entry_Amount": 0.01,
    "Base_Magic_Number": 100,
    "Entry_prot__": "------",
    "Max_Spread": 0,
    "Max_OpenPos": 90,
    "Max_OpenLots": 1,
    "Daily_prot__": "------",
    "MaxDailyLoss": 1,
    "Max_Daily_DD": 5,
    "Daily_Reset": 0,
    "Account_prot": "------",
    "Min_Equity": 500,
    "MaxEquity_DD": 5,
    "Max_Equity": 100000,
    "_NewsFilter_": "------",
    "News_Priority": "NewsFilter_HighOnly",
    "News_Currencies": "USD,CAD,EUR",
    "News_BeforeMedium": 2,
    "News_AfterMedium": 2,
    "News_BeforeHigh": 2,
    "News_AfterHigh": 5,
    "News_ViewCount": 10,
    "__Stats_____": "------",
    "Pos_Stat": true,
    "Robot_Stats": true
  },
  "original_code": "/**\n * EA Studio Portfolio Expert Advisor\n *\n * Exported from Expert Advisor Studio\n * MQL base code updated on 2024-08-22\n * Website https://eas.forexsb.com\n *\n * Copyright 2025, Forex Software Ltd.\n *\n * This Portfolio Expert works in MetaTrader 5 hedging accounts.\n * It opens separate positions for each strategy.\n * Every position has an unique magic number, which corresponds to the index of the strategy.\n *\n * Risk Disclosure\n *\n * Futures and forex trading contains substantial risk and is not for every investor.\n * An investor could potentially lose all or more than the initial investment.\n * Risk capital is money that can be lost without jeopardizing ones\u2019 financial security or life style.\n * Only risk capital should be used for trading and only those with sufficient risk capital should consider trading.\n */\n\n#property copyright \"Forex Software Ltd.\"\n#property version   \"4.2\"\n#property strict\n\nstatic input double Entry_Amount       =    0.01; // Entry lots\nstatic input int    Base_Magic_Number  =     100; // Base Magic Number\n\nstatic input string Entry_prot__ = \"------\"; // --- Entry Protections ---\nstatic input int    Max_Spread   =        0; // Max spread (points)\nstatic input int    Max_OpenPos  =       90; // Max open positions (current expert)\nstatic input double Max_OpenLots =     1.00; // Max open lots (current expert)\n\nstatic input string Daily_prot__ = \"------\"; // --- Daily Protections ---\nstatic input int    MaxDailyLoss =        1; // Maximum daily loss (currency)\nstatic input double Max_Daily_DD =     5.00; // Maximum daily drawdown %\nstatic input int    Daily_Reset  =        0; // Daily reset hour (terminal time)\n\nstatic input string Account_prot = \"------\"; // --- Account Protections ---\nstatic input int    Min_Equity   =      500; // Minimum equity (currency)\nstatic input double MaxEquity_DD =     5.00; // Maximum equity drawdown %\nstatic input int    Max_Equity   =   100000; // Maximum equity (currency)\n\nstatic input string _NewsFilter_ = \"------\"; // --- News Filter ---\nenum NewsFilterPriority\n  {\n   NewsFilter_Disabled,     // News filter disabled\n   NewsFilter_HighOnly,     // High news filter\n   NewsFilter_HighAndMedium // Medium and High news filter\n  };\nstatic input NewsFilterPriority News_Priority = NewsFilter_HighOnly;       // News priority\nstatic input string News_Currencies   = \"USD,CAD,EUR\"; // News currencies\nstatic input int    News_BeforeMedium =  2; // Before Medium news (minutes)\nstatic input int    News_AfterMedium  =  2; // After Medium news (minutes)\nstatic input int    News_BeforeHigh   =  2; // Before High news (minutes)\nstatic input int    News_AfterHigh    =  5; // After High news (minutes)\nstatic input int    News_ViewCount    = 10; // News records to show\n\nstatic input string __Stats_____ = \"------\"; // --- Stats ---\nstatic input bool   Pos_Stat     =     true; // Position stats\nstatic input bool   Robot_Stats  =     true; // Trading stats\n\n#define TRADE_RETRY_COUNT 4\n#define TRADE_RETRY_WAIT  100\n#define OP_FLAT           -1\n#define OP_BUY            ORDER_TYPE_BUY\n#define OP_SELL           ORDER_TYPE_SELL\n\nstring robotTagline  = \"A Portfolio Expert from Expert Advisor Studio\";\n\n// Session time is set in seconds from 00:00\nconst int  sessionSundayOpen          =     0; // 00:00\nconst int  sessionSundayClose         = 86400; // 24:00\nconst int  sessionMondayThursdayOpen  =     0; // 00:00\nconst int  sessionMondayThursdayClose = 86400; // 24:00\nconst int  sessionFridayOpen          =     0; // 00:00\nconst int  sessionFridayClose         = 86400; // 24:00\nconst bool sessionIgnoreSunday        = false;\nconst bool sessionCloseAtSessionClose = false;\nconst bool sessionCloseAtFridayClose  = false;\n\nconst int    strategiesCount = 5;\nconst double sigma           = 0.000001;\nconst int    requiredBars    = 100;\n\ndatetime lastStatsUpdate = 0;\ndatetime barTime;\ndouble   stopLevel;\ndouble   pip;\nbool     setProtectionSeparately = false;\nint      indHandlers[5][12][2];\n\nint    maxRectangles = 0;\nint    maxLabels     = 0;\nint    posStatCount  = 0;\ndouble posStatLots   = 0;\ndouble posStatProfit = 0;\n\nstring accountProtectionMessage = \"\";\nstring entryProtectionMessage   = \"\";\n\nstruct NewsRecord\n  {\n   datetime time;\n   string   priority;\n   string   currency;\n   string   title;\n  };\n\nNewsRecord newsRecords[];\nstring   newsCurrencies[];\ndatetime lastNewsUpdate = 0;\nstring   loadNewsError  = \"\";\nbool     isNewsFeedOk   = true;\n\nstring   accMaxEquityGlobalVarName       = \"accMaxEquity123456789\";\nstring   accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";\nstring   accMaxDailyEquityGlobalVarName  = \"accMaxDailyEquity123456789\";\nstring   accEntrySuspendGlobalVarName    = \"accEntrySuspend123456789\";\ndouble   equityDrawdownPercent           = 0;\ndatetime dailyDrawdownLastReset          = 0;\ndouble   dailyLoss                       = 0;\ndouble   dailyDrawdown                   = 0;\n\nENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nenum OrderScope\n  {\n   ORDER_SCOPE_UNDEFINED,\n   ORDER_SCOPE_ENTRY,\n   ORDER_SCOPE_EXIT\n  };\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nenum OrderDirection\n  {\n   ORDER_DIRECTION_NONE,\n   ORDER_DIRECTION_BUY,\n   ORDER_DIRECTION_SELL,\n   ORDER_DIRECTION_BOTH\n  };\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstruct Position\n  {\n   int    Type;\n   ulong  Ticket;\n   int    MagicNumber;\n   double Lots;\n   double Price;\n   double StopLoss;\n   double TakeProfit;\n  };\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstruct Signal\n  {\n   int            MagicNumber;\n   OrderScope     Scope;\n   OrderDirection Direction;\n   int            StopLossPips;\n   int            TakeProfitPips;\n   bool           IsTrailingStop;\n   bool           OppositeReverse;\n  };\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nint OnInit()\n  {\n   Comment(\"\");\n   DeleteObjects();\n\n   barTime   = Time(0);\n   stopLevel = (int) SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);\n   pip       = GetPipValue();\n\n   accountProtectionMessage = \"\";\n   entryProtectionMessage   = \"\";\n\n   InitIndicatorHandlers();\n\n   ParseNewsCurrenciesText();\n   lastNewsUpdate = TimeCurrent();\n   if(!MQLInfoInteger(MQL_TESTER))\n      LoadNews();\n\n   OnTick();\n   ChartRedraw(0);\n\n   return INIT_SUCCEEDED;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid OnDeinit(const int reason)\n  {\n   DeleteObjects();\n\n   if(accountProtectionMessage != \"\")\n      Comment(accountProtectionMessage);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid OnTick(void)\n  {\n   if(!MQLInfoInteger(MQL_TESTER))\n     {\n      UpdateAccountProtection();\n      CheckAccountProtection();\n\n      const datetime time = TimeCurrent();\n      if(time > lastStatsUpdate + 3)\n        {\n         lastStatsUpdate = time;\n         if(Max_OpenPos > sigma || Max_OpenLots > sigma)\n            SetPosStats();\n\n         UpdateStats();\n        }\n\n      if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)\n        {\n         lastNewsUpdate = time;\n         LoadNews();\n        }\n     }\n\n   if(IsForceSessionClose())\n     {\n      CloseAllPositions();\n      return;\n     }\n\n   const datetime time = Time(0);\n   if(time > barTime)\n     {\n      barTime = time;\n      OnBar();\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid OnBar(void)\n  {\n   if(IsOutOfSession())\n      return;\n\n   if(Max_OpenPos || Max_OpenLots)\n      SetPosStats();\n\n   Signal signalList[];\n   SetSignals(signalList);\n   int signalsCount = ArraySize(signalList);\n\n   for (int i = 0; i < signalsCount; i += 1)\n      ManageSignal(signalList[i]);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid ManageSignal(Signal &signal)\n  {\n   Position position = CreatePosition(signal.MagicNumber);\n\n   if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)\n     {\n      if((signal.Direction == ORDER_DIRECTION_BOTH) ||\n         (position.Type == OP_BUY  && signal.Direction == ORDER_DIRECTION_SELL) ||\n         (position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY ) )\n        {\n         ClosePosition(position);\n         return;\n        }\n\n      if(signal.IsTrailingStop)\n        {\n         double trailingStop = GetTrailingStopPrice(position, signal.StopLossPips);\n         ManageTrailingStop(position, trailingStop);\n        }\n     }\n\n   if(position.Type != OP_FLAT && signal.OppositeReverse)\n     {\n      if((position.Type == OP_BUY  && signal.Direction == ORDER_DIRECTION_SELL) ||\n         (position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY ))\n        {\n         ClosePosition(position);\n         ManageSignal(signal);\n         return;\n        }\n     }\n\n   if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY) &&\n      (signal.Direction == ORDER_DIRECTION_BUY ||\n       signal.Direction == ORDER_DIRECTION_SELL))\n            OpenPosition(signal);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nint CountPositions(void)\n  {\n   const int minMagic = GetMagicNumber(0);\n   const int maxMagic = GetMagicNumber(strategiesCount);\n   const int posTotal = PositionsTotal();\n   int count = 0;\n\n   for(int posIndex = posTotal - 1; posIndex >= 0; posIndex--)\n     {\n      const ulong ticket = PositionGetTicket(posIndex);\n      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)\n        {\n         const long magicNumber = PositionGetInteger(POSITION_MAGIC);\n         if(magicNumber >= minMagic && magicNumber <= maxMagic)\n            count += 1;\n        }\n     }\n\n   return count;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nPosition CreatePosition(const int magicNumber)\n  {\n   Position position;\n   position.MagicNumber = magicNumber;\n   position.Type        = OP_FLAT;\n   position.Ticket      = 0;\n   position.Lots        = 0;\n   position.Price       = 0;\n   position.StopLoss    = 0;\n   position.TakeProfit  = 0;\n\n   const int posTotal = PositionsTotal();\n   for (int posIndex = 0; posIndex < posTotal; posIndex += 1)\n     {\n      const ulong ticket = PositionGetTicket(posIndex);\n      if(PositionSelectByTicket(ticket) &&\n         PositionGetString(POSITION_SYMBOL) == _Symbol &&\n         PositionGetInteger(POSITION_MAGIC) == magicNumber)\n        {\n         position.Type       = (int) PositionGetInteger(POSITION_TYPE);\n         position.Ticket     = ticket;\n         position.Lots       = NormalizeDouble( PositionGetDouble(POSITION_VOLUME),           2);\n         position.Price      = NormalizeDouble( PositionGetDouble(POSITION_PRICE_OPEN), _Digits);\n         position.StopLoss   = NormalizeDouble( PositionGetDouble(POSITION_SL),         _Digits);\n         position.TakeProfit = NormalizeDouble( PositionGetDouble(POSITION_TP),         _Digits);\n         break;\n        }\n     }\n\n   return position;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal CreateEntrySignal(int strategyIndex, bool canOpenLong,    bool canOpenShort,\n                         int stopLossPips,  int  takeProfitPips, bool isTrailingStop,\n                         bool oppositeReverse = false)\n  {\n   Signal signal;\n\n   signal.MagicNumber     = GetMagicNumber(strategyIndex);\n   signal.Scope           = ORDER_SCOPE_ENTRY;\n   signal.StopLossPips    = stopLossPips;\n   signal.TakeProfitPips  = takeProfitPips;\n   signal.IsTrailingStop  = isTrailingStop;\n   signal.OppositeReverse = oppositeReverse;\n   signal.Direction       = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH\n                                         : canOpenLong  ? ORDER_DIRECTION_BUY\n                                         : canOpenShort ? ORDER_DIRECTION_SELL\n                                                        : ORDER_DIRECTION_NONE;\n\n   return signal;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal CreateExitSignal(int strategyIndex, bool canCloseLong,   bool canCloseShorts,\n                        int stopLossPips,  int  takeProfitPips, bool isTrailingStop)\n  {\n   Signal signal;\n\n   signal.MagicNumber     = GetMagicNumber(strategyIndex);\n   signal.Scope           = ORDER_SCOPE_EXIT;\n   signal.StopLossPips    = stopLossPips;\n   signal.TakeProfitPips  = takeProfitPips;\n   signal.IsTrailingStop  = isTrailingStop;\n   signal.OppositeReverse = false;\n   signal.Direction       = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH\n                                          : canCloseLong   ? ORDER_DIRECTION_SELL\n                                          : canCloseShorts ? ORDER_DIRECTION_BUY\n                                                           : ORDER_DIRECTION_NONE;\n\n   return signal;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid OpenPosition(Signal &signal)\n  {\n   entryProtectionMessage = \"\";\n   const int spread = (int)((Ask() - Bid()) / _Point);\n   if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)\n      entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d, current: %d\\n\",\n                                             Max_OpenPos, posStatCount);\n   if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)\n      entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f, current: %.2f\\n\",\n                                             Max_OpenLots, posStatLots);\n   if(Max_Spread > sigma && spread > Max_Spread)\n      entryProtectionMessage += StringFormat(\"Protection: Max spread: %d, current: %d\\n\",\n                                             Max_Spread, spread);\n   if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)\n      entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d, current: %.2f\\n\",\n                                             MaxDailyLoss, dailyLoss);\n   if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)\n      entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%, current: %.2f%%\\n\",\n                                             Max_Daily_DD, dailyDrawdown);\n   if(GlobalVariableGet(accEntrySuspendGlobalVarName) > sigma)\n      entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",\n                                             Daily_Reset);\n\n   const int newsIndex = NewsFilterActive();\n   if(newsIndex > -1)\n     {\n      const NewsRecord newsRecord = newsRecords[newsIndex];\n      const datetime timeShift = (datetime) MathRound((TimeLocal() - TimeGMT()) / 3600.0) * 3600;\n      const string   priority  = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";\n      entryProtectionMessage  += StringFormat(\"News filter: %s %s %s %s\\n\",\n                                              priority,\n                                              TimeToString(newsRecord.time + timeShift,\n                                                           TIME_DATE | TIME_MINUTES),\n                                              newsRecord.currency,\n                                              newsRecord.title);\n     }\n\n   if(entryProtectionMessage != \"\")\n     {\n      entryProtectionMessage = TimeToString(TimeCurrent()) + \" \" +\n                               \"An entry order was canceled:\\n\" +\n                               entryProtectionMessage;\n      return;\n     }\n\n   const int    command    = OrderDirectionToCommand(signal.Direction);\n   const double stopLoss   = GetStopLossPrice(command, signal.StopLossPips);\n   const double takeProfit = GetTakeProfitPrice(command, signal.TakeProfitPips);\n   const double posLots    = Entry_Amount;\n\n   if(ManageOrderSend(command, posLots, stopLoss, takeProfit, 0, signal.MagicNumber))\n     {\n      posStatCount += 1;\n      posStatLots  += posLots;\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid ClosePosition(Position &position)\n  {\n   const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;\n\n   if(ManageOrderSend(command, position.Lots, 0, 0, position.Ticket, position.MagicNumber))\n     {\n      posStatCount -= 1;\n      posStatLots  -= position.Lots;\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CloseAllPositions(void)\n  {\n   for (int i = 0; i < strategiesCount; i += 1)\n     {\n      const int magicNumber = GetMagicNumber(i);\n      Position position = CreatePosition(magicNumber);\n\n      if(position.Type == OP_BUY || position.Type == OP_SELL)\n         ClosePosition(position);\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool ManageOrderSend(int command, double lots, double stopLoss, double takeProfit, ulong ticket, int magicNumber)\n  {\n   for(int attempt = 0; attempt < TRADE_RETRY_COUNT; attempt++)\n     {\n      if(IsTradeContextFree())\n        {\n         MqlTradeRequest request;\n         MqlTradeResult  result;\n         ZeroMemory(request);\n         ZeroMemory(result);\n\n         request.action       = TRADE_ACTION_DEAL;\n         request.symbol       = _Symbol;\n         request.volume       = lots;\n         request.type         = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;\n         request.price        = command == OP_BUY ? Ask() : Bid();\n         request.type_filling = orderFillingType;\n         request.deviation    = 10;\n         request.sl           = stopLoss;\n         request.tp           = takeProfit;\n         request.magic        = magicNumber;\n         request.position     = ticket;\n         request.comment      = IntegerToString(magicNumber);\n\n         bool isOrderCheck = CheckOrder(request);\n         bool isOrderSend  = false;\n\n         if(isOrderCheck)\n           {\n            ResetLastError();\n            isOrderSend = OrderSend(request, result);\n           }\n\n         if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)\n            return true;\n        }\n\n      Sleep(TRADE_RETRY_WAIT);\n      Print(\"Order Send retry: \" + IntegerToString(attempt + 2));\n     }\n   return false;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid ModifyPosition(double stopLoss, double takeProfit, ulong ticket, int magicNumber)\n  {\n   for (int attempt = 0; attempt < TRADE_RETRY_COUNT; attempt++)\n     {\n      if( IsTradeContextFree() )\n        {\n         MqlTradeRequest request;\n         MqlTradeResult  result;\n         ZeroMemory(request);\n         ZeroMemory(result);\n\n         request.action   = TRADE_ACTION_SLTP;\n         request.symbol   = _Symbol;\n         request.sl       = stopLoss;\n         request.tp       = takeProfit;\n         request.magic    = magicNumber;\n         request.position = ticket;\n         request.comment  = IntegerToString(magicNumber);\n\n         bool isOrderCheck = CheckOrder(request);\n         bool isOrderSend  = false;\n\n         if(isOrderCheck)\n           {\n            ResetLastError();\n            isOrderSend = OrderSend(request, result);\n           }\n\n         if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)\n            return;\n        }\n\n      Sleep(TRADE_RETRY_WAIT);\n      Print(\"Order Send retry: \" + IntegerToString(attempt + 2));\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool CheckOrder(MqlTradeRequest &request)\n  {\n   MqlTradeCheckResult check;\n   ZeroMemory(check);\n   ResetLastError();\n\n   if(OrderCheck(request, check))\n      return true;\n\n   Print(\"Error with OrderCheck: \" + check.comment);\n\n   if(check.retcode == TRADE_RETCODE_INVALID_FILL)\n     {\n      switch (orderFillingType)\n        {\n         case ORDER_FILLING_FOK:\n            Print(\"Filling mode changed to: ORDER_FILLING_IOC\");\n            orderFillingType = ORDER_FILLING_IOC;\n            break;\n         case ORDER_FILLING_IOC:\n            Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");\n            orderFillingType = ORDER_FILLING_RETURN;\n            break;\n         case ORDER_FILLING_RETURN:\n            Print(\"Filling mode changed to: ORDER_FILLING_FOK\");\n            orderFillingType = ORDER_FILLING_FOK;\n            break;\n        }\n\n      request.type_filling = orderFillingType;\n\n      return CheckOrder(request);\n     }\n\n   return false;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble GetStopLossPrice(const int command, const int stopLossPips)\n  {\n   if(stopLossPips == 0)\n      return 0;\n\n   const double delta    = MathMax(pip * stopLossPips, _Point * stopLevel);\n   const double stopLoss = command == OP_BUY ? Bid() - delta : Ask() + delta;\n\n   return NormalizeDouble(stopLoss, _Digits);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble GetTakeProfitPrice(const int command, const int takeProfitPips)\n  {\n   if(takeProfitPips == 0)\n      return 0;\n\n   const double delta      = MathMax(pip * takeProfitPips, _Point * stopLevel);\n   const double takeProfit = command == OP_BUY ? Bid() + delta : Ask() - delta;\n\n   return NormalizeDouble(takeProfit, _Digits);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble GetTrailingStopPrice(Position &position, const int stopLoss)\n  {\n   const double bid             = Bid();\n   const double ask             = Ask();\n   const double spread          = ask - bid;\n   const double stopLevelPoints = _Point * stopLevel;\n   const double stopLossPoints  = pip * stopLoss;\n\n   if(position.Type == OP_BUY)\n     {\n      const double newStopLoss = High(1) - stopLossPoints;\n      if(position.StopLoss <= newStopLoss - pip)\n         return newStopLoss < bid\n                  ? newStopLoss >= bid - stopLevelPoints\n                     ? bid - stopLevelPoints\n                     : newStopLoss\n                  : bid;\n     }\n\n   if(position.Type == OP_SELL)\n     {\n      const double newStopLoss = Low(1) + spread + stopLossPoints;\n      if(position.StopLoss >= newStopLoss + pip)\n         return newStopLoss > ask\n                  ? newStopLoss <= ask + stopLevelPoints\n                     ? ask + stopLevelPoints\n                     : newStopLoss\n                  : ask;\n     }\n\n   return position.StopLoss;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid ManageTrailingStop(Position &position, const double trailingStop)\n  {\n   if((position.Type == OP_BUY  && MathAbs(trailingStop - Bid()) < _Point) ||\n      (position.Type == OP_SELL && MathAbs(trailingStop - Ask()) < _Point))\n     {\n      ClosePosition(position);\n      return;\n     }\n\n   if(MathAbs(trailingStop - position.StopLoss) > _Point)\n     {\n      position.StopLoss = NormalizeDouble(trailingStop, _Digits);\n      ModifyPosition(position.StopLoss, position.TakeProfit, position.Ticket, position.MagicNumber);\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble Bid(void)\n  {\n   return SymbolInfoDouble(_Symbol, SYMBOL_BID);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble Ask(void)\n  {\n   return SymbolInfoDouble(_Symbol, SYMBOL_ASK);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndatetime Time(const int bar)\n  {\n   datetime buffer[];\n   ArrayResize(buffer, 1);\n   return CopyTime(_Symbol, _Period, bar, 1, buffer) == 1 ? buffer[0] : 0;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble Open(const int bar)\n  {\n   double buffer[];\n   ArrayResize(buffer, 1);\n   return CopyOpen(_Symbol, _Period, bar, 1, buffer) == 1 ? buffer[0] : 0;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble High(const int bar)\n  {\n   double buffer[];\n   ArrayResize(buffer, 1);\n   return CopyHigh(_Symbol, _Period, bar, 1, buffer) == 1 ? buffer[0] : 0;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble Low(const int bar)\n  {\n   double buffer[];\n   ArrayResize(buffer, 1);\n   return CopyLow(_Symbol, _Period, bar, 1, buffer) == 1 ? buffer[0] : 0;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble Close(const int bar)\n  {\n   double buffer[];\n   ArrayResize(buffer, 1);\n   return CopyClose(_Symbol, _Period, bar, 1, buffer) == 1 ? buffer[0] : 0;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ndouble GetPipValue(void)\n  {\n   return _Digits == 4 || _Digits == 5 ? 0.0001\n        : _Digits == 2 || _Digits == 3 ? 0.01\n                        : _Digits == 1 ? 0.1 : 1;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool IsTradeAllowed(void)\n  {\n   return (bool) MQL5InfoInteger(MQL5_TRADE_ALLOWED);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid RefreshRates(void)\n  {\n   // A stub function to make it compatible with MQL4\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nint DayOfWeek(void)\n  {\n   MqlDateTime mqlTime;\n   TimeToStruct(Time(0), mqlTime);\n   return mqlTime.day_of_week;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool IsTradeContextFree(void)\n  {\n   if(IsTradeAllowed())\n      return true;\n\n   const uint startWait = GetTickCount();\n   Print(\"Trade context is busy! Waiting...\");\n\n   while(true)\n     {\n      if(IsStopped())\n         return false;\n\n      const uint diff = GetTickCount() - startWait;\n      if(diff > 30 * 1000)\n        {\n         Print(\"The waiting limit exceeded!\");\n         return false;\n        }\n\n      if(IsTradeAllowed())\n        {\n         RefreshRates();\n         return true;\n        }\n\n      Sleep(TRADE_RETRY_WAIT);\n     }\n\n   return true;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool IsOutOfSession(void)\n  {\n   const int dayOfWeek    = DayOfWeek();\n   const int periodStart  = int(Time(0) % 86400);\n   const int periodLength = PeriodSeconds(_Period);\n   const int periodFix    = periodStart + (sessionCloseAtSessionClose ? periodLength : 0);\n   const int friBarFix    = periodStart + (sessionCloseAtFridayClose ||\n                                           sessionCloseAtSessionClose ? periodLength : 0);\n\n   return dayOfWeek == 0 && sessionIgnoreSunday ? true\n        : dayOfWeek == 0 ? periodStart < sessionSundayOpen ||\n                           periodFix   > sessionSundayClose\n        : dayOfWeek  < 5 ? periodStart < sessionMondayThursdayOpen ||\n                           periodFix   > sessionMondayThursdayClose\n                         : periodStart < sessionFridayOpen ||\n                           friBarFix   > sessionFridayClose;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool IsForceSessionClose(void)\n  {\n   if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)\n      return false;\n\n   const int dayOfWeek = DayOfWeek();\n   const int periodEnd = int(Time(0) % 86400) + PeriodSeconds(_Period);\n\n   return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose\n        : dayOfWeek  < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose\n        : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid UpdateAccountProtection(void)\n  {\n   const double equity = AccountInfoDouble(ACCOUNT_EQUITY);\n\n   double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);\n   if(equity > maxEquity)\n     {\n      maxEquity = equity;\n      GlobalVariableSet(accMaxEquityGlobalVarName, maxEquity);\n     }\n\n   equityDrawdownPercent = 100 * (maxEquity - equity) / maxEquity;\n\n   if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))\n      GlobalVariableSet(accMaxDailyEquityGlobalVarName, equity);\n\n   const double balance = AccountInfoDouble(ACCOUNT_BALANCE);\n   if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))\n      GlobalVariableSet(accMaxDailyBalanceGlobalVarName, balance);\n\n   double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);\n   double maxDailyEquity  = GlobalVariableGet(accMaxDailyEquityGlobalVarName);\n\n   const datetime currentTime = TimeCurrent();\n   MqlDateTime dateTime;\n   TimeToStruct(currentTime, dateTime);\n   if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)\n     {\n      dailyDrawdownLastReset = currentTime;\n      GlobalVariableSet(accMaxDailyEquityGlobalVarName,  equity);\n      GlobalVariableSet(accMaxDailyBalanceGlobalVarName, balance);\n      GlobalVariableSet(accEntrySuspendGlobalVarName,    0);\n      maxDailyBalance = balance;\n      maxDailyEquity  = equity;\n      entryProtectionMessage = \"\";\n     }\n\n   dailyLoss     = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;\n   dailyDrawdown = 100 * (maxDailyEquity - equity) / maxDailyEquity;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckAccountProtection(void)\n  {\n   const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);\n\n   if(Min_Equity > sigma && accountEquity <= Min_Equity)\n     {\n      ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\", accountEquity));\n      return;\n     }\n\n   if(Max_Equity > sigma && accountEquity >= Max_Equity)\n     {\n      ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\", accountEquity));\n      return;\n     }\n\n   if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)\n     {\n      ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\", equityDrawdownPercent));\n      return;\n     }\n\n   if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)\n     {\n      entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\", dailyLoss);\n      GlobalVariableSet(accEntrySuspendGlobalVarName, 1);\n      CloseAllPositions();\n      return;\n     }\n\n   if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)\n     {\n      entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\", dailyDrawdown);\n      GlobalVariableSet(accEntrySuspendGlobalVarName, 1);\n      CloseAllPositions();\n      return;\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid ActivateProtection(const string message)\n  {\n   CloseAllPositions();\n   DeleteObjects();\n\n   accountProtectionMessage  = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\", robotTagline, Base_Magic_Number);\n   accountProtectionMessage += message + \"\\n\";\n   accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";\n   accountProtectionMessage += \"The Portfolio Expert was turned off.\";\n   Comment(accountProtectionMessage);\n   Print(accountProtectionMessage);\n\n   Sleep(20 * 1000);\n   ExpertRemove();\n   OnDeinit(0);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid SetPosStats(void)\n  {\n   posStatCount  = 0;\n   posStatLots   = 0;\n   posStatProfit = 0;\n\n   for(int i = PositionsTotal() - 1; i >= 0; i -= 1)\n     {\n      const ulong ticket = PositionGetTicket(i);\n      if(ticket == 0 || !PositionSelectByTicket(ticket))\n         continue;\n\n      const string posSymbol = PositionGetString (POSITION_SYMBOL);\n      const long   posMagic  = PositionGetInteger(POSITION_MAGIC);\n      if(posSymbol != _Symbol || !IsOwnDeal(posMagic))\n         continue;\n\n      posStatCount  += 1;\n      posStatLots   += PositionGetDouble(POSITION_VOLUME);\n      posStatProfit += PositionGetDouble(POSITION_PROFIT) +\n                       PositionGetDouble(POSITION_SWAP);\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid UpdateStats(void)\n  {\n   string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\", robotTagline, Base_Magic_Number);\n\n   if(entryProtectionMessage != \"\")\n      statsInfo += \"\\n\" + entryProtectionMessage;\n   if(Pos_Stat)\n      statsInfo += GetPositionStats() + \"\\n\";\n   if(Robot_Stats)\n      statsInfo += GetRobotStats() + \"\\n\";\n   if(Max_Spread   > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma ||\n      Max_Daily_DD > sigma || Min_Equity  > sigma || Max_Equity   > sigma || MaxEquity_DD > sigma)\n      statsInfo += GetProtectionInfo();\n   if(News_Priority != NewsFilter_Disabled)\n      statsInfo += GetNewsText() + \"\\n\";\n\n   RenderStats(statsInfo);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstring GetProtectionInfo(void)\n  {\n   string protectionInfo = \"\\n            ..:: Active Protections ::..\\n\";\n\n   if(Max_Spread > sigma)\n      protectionInfo += StringFormat(\"Max spread: %d, current: %d\\n\",\n                                     Max_Spread, (int)MathRound((Ask() - Bid()) / _Point));\n   if(Max_OpenPos > sigma)\n      protectionInfo += StringFormat(\"Max open positions: %d, current: %d\\n\",\n                                     Max_OpenPos, posStatCount);\n   if(Max_OpenLots > sigma)\n      protectionInfo += StringFormat(\"Max open lots: %.2f, current: %.2f\\n\",\n                                     Max_OpenLots, posStatLots);\n   if(MaxDailyLoss > sigma)\n      protectionInfo += StringFormat(\"Max daily loss: %d, current: %.2f\\n\",\n                                     MaxDailyLoss, dailyLoss);\n   if(Max_Daily_DD > sigma)\n      protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%, current: %.2f%%\\n\",\n                                     Max_Daily_DD, dailyDrawdown);\n   if(Min_Equity > sigma)\n      protectionInfo += StringFormat(\"Min equity: %d, current: %.2f\\n\",\n                                     Min_Equity, AccountInfoDouble(ACCOUNT_EQUITY));\n   if(MaxEquity_DD > sigma)\n      protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%, current: %.2f%%\\n\",\n                                     MaxEquity_DD, equityDrawdownPercent);\n   if(Max_Equity > sigma)\n      protectionInfo += StringFormat(\"Max equity: %d, current: %.2f\\n\",\n                                     Max_Equity, AccountInfoDouble(ACCOUNT_EQUITY));\n\n   return protectionInfo;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstring GetPositionStats(void)\n  {\n   return \"\\n            ..:: Positions Stats ::..\\n\" +\n          (posStatCount > 0 ? StringFormat(\"Positions: %d, Lots: %.2f, Profit %.2f\",\n                                           posStatCount, posStatLots, posStatProfit)\n                            : \"Positions: no open position\");\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstring GetRobotStats(void)\n  {\n   return \"\\n            ..:: Trading Stats ::..\\n\" +\n          \"  1-day: \" + GetRobotStatsDays(1) + \"\\n\" +\n          \"  7-day: \" + GetRobotStatsDays(7) + \"\\n\" +\n          \"30-day: \"  + GetRobotStatsDays(30);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstring GetRobotStatsDays(const int days)\n  {\n   double grossProfit     = 0;\n   double grossLoss       = 0;\n   int    histDealsCnt    = 0;\n   double histDealsProfit = 0;\n\n   const datetime timeCurrent = TimeCurrent();\n   const datetime timeStart   = timeCurrent - days * PeriodSeconds(PERIOD_D1);\n   HistorySelect(timeStart, timeCurrent);\n   const int deals = HistoryDealsTotal();\n\n   for(int i = 0; i < deals; i += 1)\n     {\n      const ulong ticket = HistoryDealGetTicket(i);\n      if(ticket == 0)\n         continue;\n      if(HistoryDealGetString(ticket, DEAL_SYMBOL) != _Symbol)\n         continue;\n\n      // When we close a position manually it gets dealMagic = 0\n      const long dealMagic = HistoryDealGetInteger(ticket, DEAL_MAGIC);\n      if(dealMagic > 0 && !IsOwnDeal(dealMagic))\n         continue;\n\n      const long dealType = HistoryDealGetInteger(ticket, DEAL_TYPE);\n      if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)\n         continue;\n      const long dealEntry = HistoryDealGetInteger(ticket, DEAL_ENTRY);\n      if(dealEntry != DEAL_ENTRY_OUT)\n         continue;\n\n      const double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT) +\n                            HistoryDealGetDouble(ticket, DEAL_SWAP)   +\n                            HistoryDealGetDouble(ticket, DEAL_COMMISSION);\n\n      histDealsProfit += profit;\n      histDealsCnt    += 1;\n\n      if(profit > sigma)\n         grossProfit += profit;\n      if(profit < -sigma)\n         grossLoss -= profit;\n     }\n\n   const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;\n\n   return StringFormat(\"Trades: %d, Profit: %.2f, Profit factor: %.2f\",\n                       histDealsCnt, histDealsProfit, profitFactor);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstring GetNewsInfo(void)\n  {\n   return \"\";\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid RenderStats(const string text)\n  {\n   string lines[];\n   const int linesCount = StringSplit(text, '\\n', lines);\n\n   int lineWidth, lineHeight;\n   TextGetSize(robotTagline, lineWidth, lineHeight);\n\n   if(maxRectangles == 0)\n      RectLabelCreate(0, \"Stats_background\", 0, 0, 30, lineWidth,\n                      linesCount * lineHeight, GetChartBackColor(0));\n\n   const color foreColor = GetChartForeColor(0);\n   for(int i = 0; i < linesCount; i += 1)\n     {\n      if(lines[i] == \"\")\n         lines[i] = \" \";\n      string labelName = \"label\" + IntegerToString(i);\n      if(i < maxLabels)\n         LabelUpdate(0, labelName, lines[i]);\n      else\n         LabelCreate(0, labelName, 0, 10, 20 + i * lineHeight,\n                     CORNER_LEFT_UPPER, lines[i], \"Arial\", 10, foreColor);\n\n      int lnWidth, lnHeight;\n      TextGetSize(lines[i], lnWidth, lnHeight);\n      if(lnWidth > lineWidth)\n         lineWidth = lnWidth;\n     }\n   ObjectSetInteger(0, \"Stats_background\", OBJPROP_XSIZE,\n                    (int) MathRound(lineWidth * 0.90));\n   ObjectSetInteger(0, \"Stats_background\", OBJPROP_YSIZE,\n                    linesCount * lineHeight);\n   for(int i = linesCount; i < maxLabels; i += 1)\n      LabelUpdate(0, \"label\" + IntegerToString(i), \" \");\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid RectLabelCreate(\n   const long             chartId    = 0,                 // chart's ID\n   const string           name       = \"RectLabel\",       // label name\n   const int              sub_window = 0,                 // sub-window index\n   const int              x          = 0,                 // X coordinate\n   const int              y          = 0,                 // Y coordinate\n   const int              width      = 50,                // width\n   const int              height     = 18,                // height\n   const color            back_clr   = clrBlack,          // background color\n   const ENUM_BORDER_TYPE border     = BORDER_SUNKEN,     // border type\n   const ENUM_BASE_CORNER corner     = CORNER_LEFT_UPPER, // chart corner for anchoring\n   const color            clr        = clrBlack,          // flat border color (Flat)\n   const ENUM_LINE_STYLE  style      = STYLE_SOLID,       // flat border style\n   const int              line_width = 0,                 // flat border width\n   const bool             back       = false,             // in the background\n   const bool             selection  = false,             // highlight to move\n   const bool             hidden     = true,              // hidden in the object list\n   const long             z_order    = 0)                 // priority for mouse click\n  {\n   if(!ObjectCreate(chartId, name, OBJ_RECTANGLE_LABEL, sub_window, 0, 0)) return;\n   maxRectangles += 1;\n   ObjectSetInteger(chartId, name, OBJPROP_XDISTANCE,   x);\n   ObjectSetInteger(chartId, name, OBJPROP_YDISTANCE,   y);\n   ObjectSetInteger(chartId, name, OBJPROP_XSIZE,       width);\n   ObjectSetInteger(chartId, name, OBJPROP_YSIZE,       height);\n   ObjectSetInteger(chartId, name, OBJPROP_BGCOLOR,     back_clr);\n   ObjectSetInteger(chartId, name, OBJPROP_BORDER_TYPE, border);\n   ObjectSetInteger(chartId, name, OBJPROP_CORNER,      corner);\n   ObjectSetInteger(chartId, name, OBJPROP_COLOR,       clr);\n   ObjectSetInteger(chartId, name, OBJPROP_STYLE,       style);\n   ObjectSetInteger(chartId, name, OBJPROP_WIDTH,       line_width);\n   ObjectSetInteger(chartId, name, OBJPROP_BACK,        back);\n   ObjectSetInteger(chartId, name, OBJPROP_SELECTABLE,  selection);\n   ObjectSetInteger(chartId, name, OBJPROP_SELECTED,    selection);\n   ObjectSetInteger(chartId, name, OBJPROP_HIDDEN,      hidden);\n   ObjectSetInteger(chartId, name, OBJPROP_ZORDER,      z_order);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid LabelCreate(\n   const long              chartId=0,                // chart's ID\n   const string            name=\"Label\",             // label name\n   const int               sub_window=0,             // sub-window index\n   const int               x=0,                      // X coordinate\n   const int               y=0,                      // Y coordinate\n   const ENUM_BASE_CORNER  corner=CORNER_LEFT_UPPER, // chart corner for anchoring\n   const string            text=\"Label\",             // text\n   const string            font=\"Arial\",             // font\n   const int               font_size=10,             // font size\n   const color             clr=clrYellow,            // color\n   const double            angle=0.0,                // text slope\n   const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER, // anchor type\n   const bool              back=false,               // in the background\n   const bool              selection=false,          // highlight to move\n   const bool              hidden=true,              // hidden in the object list\n   const long              z_order=0)                // priority for mouse click\n  {\n   if(!ObjectCreate(chartId, name, OBJ_LABEL, sub_window, 0 , 0)) return;\n   maxLabels += 1;\n   ObjectSetInteger(chartId, name, OBJPROP_XDISTANCE,  x);\n   ObjectSetInteger(chartId, name, OBJPROP_YDISTANCE,  y);\n   ObjectSetInteger(chartId, name, OBJPROP_CORNER,     corner);\n   ObjectSetString( chartId, name, OBJPROP_TEXT,       text);\n   ObjectSetString( chartId, name, OBJPROP_FONT,       font);\n   ObjectSetString( chartId, name, OBJPROP_TOOLTIP,    \"\\n\");\n   ObjectSetInteger(chartId, name, OBJPROP_FONTSIZE,   font_size);\n   ObjectSetDouble( chartId, name, OBJPROP_ANGLE,      angle);\n   ObjectSetInteger(chartId, name, OBJPROP_ANCHOR,     anchor);\n   ObjectSetInteger(chartId, name, OBJPROP_COLOR,      clr);\n   ObjectSetInteger(chartId, name, OBJPROP_BACK,       back);\n   ObjectSetInteger(chartId, name, OBJPROP_SELECTABLE, selection);\n   ObjectSetInteger(chartId, name, OBJPROP_SELECTED,   selection);\n   ObjectSetInteger(chartId, name, OBJPROP_HIDDEN,     hidden);\n   ObjectSetInteger(chartId, name, OBJPROP_ZORDER,     z_order);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid LabelUpdate(int chartId, string name, string text)\n  {\n   ObjectSetString(chartId, name, OBJPROP_TEXT, text);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ncolor GetChartForeColor(const long chartId=0)\n  {\n   long foreColor = clrWhite;\n   ChartGetInteger(chartId, CHART_COLOR_FOREGROUND, 0, foreColor);\n   return (color) foreColor;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\ncolor GetChartBackColor(const long chartId=0)\n  {\n   long backColor = clrBlack;\n   ChartGetInteger(chartId, CHART_COLOR_BACKGROUND, 0, backColor);\n   return (color) backColor;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid DeleteObjects(void)\n  {\n   if(ObjectFind(0, \"Stats_background\") == 0)\n      ObjectDelete(0, \"Stats_background\");\n   maxLabels = MathMax(maxLabels, 100);\n   for(int i = 0; i < maxLabels; i++)\n     {\n      const string objName = \"label\" + IntegerToString(i);\n      if(ObjectFind(0, objName) == 0)\n         ObjectDelete(0, objName);\n     }\n   maxRectangles = 0;\n   maxLabels     = 0;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid InitGlobalVariables(void)\n  {\n   if(MQLInfoInteger(MQL_TESTER)) return;\n\n   const string accountNumberText = (string)AccountInfoInteger(ACCOUNT_LOGIN);\n\n   accMaxEquityGlobalVarName       = \"Max_Equity_\"         + accountNumberText;\n   accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\"  + accountNumberText;\n   accMaxDailyEquityGlobalVarName  = \"Max_Daily_Equity_\"   + accountNumberText;\n   accEntrySuspendGlobalVarName    = \"Is_Entry_Suspended_\" + accountNumberText;\n\n   if(!GlobalVariableCheck(accMaxEquityGlobalVarName))\n      GlobalVariableSet(accMaxEquityGlobalVarName, AccountInfoDouble(ACCOUNT_EQUITY));\n   if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))\n      GlobalVariableSet(accMaxDailyBalanceGlobalVarName, AccountInfoDouble(ACCOUNT_BALANCE));\n   if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))\n      GlobalVariableSet(accMaxDailyEquityGlobalVarName, AccountInfoDouble(ACCOUNT_EQUITY));\n   if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))\n      GlobalVariableSet(accEntrySuspendGlobalVarName, 0);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid LoadNews(void)\n  {\n   loadNewsError = \"\";\n   string error = \"\";\n   const string newsContent = GetNewsContent(error);\n   if(error != \"\")\n     {\n      loadNewsError = error;\n      return;\n     }\n\n   if(newsContent == \"\")\n     {\n      loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\", GetLastError());\n      return;\n     }\n\n   ParseNewsContent(newsContent, error);\n\n   if(error != \"\")\n      loadNewsError = error;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid ParseNewsContent(const string newsContent, string &error)\n  {\n   string lines[];\n   const int linesLen = StringSplit(newsContent, '\\n', lines);\n\n   if(linesLen == -1)\n     {\n      error = \"Cannot parse the news feed\";\n      return;\n     }\n\n   ArrayResize(newsRecords, linesLen);\n\n   for(int i = 0; i < linesLen; i += 1)\n     {\n      string fields[];\n      const int fieldsLen = StringSplit(lines[i], ';', fields);\n\n      if(fieldsLen != 4)\n        {\n         error = \"Cannot parse the news feed records\";\n         return;\n        }\n\n      NewsRecord record;\n      record.time     = (datetime) StringToInteger(fields[0]);\n      record.priority = fields[1];\n      record.currency = fields[2];\n      record.title    = fields[3];\n\n      newsRecords[i] = record;\n     }\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstring GetNewsContent(string &error)\n  {\n   const string url = \"https://forexsb.com/updates/news-feed.txt\";\n\n   char   reqBody[], resData[];\n   string headers;\n\n   ResetLastError();\n\n   const int resCode  = WebRequest(\"GET\", url, \"\", 10000, reqBody, resData, headers);\n   const int resError = GetLastError();\n\n   isNewsFeedOk = false;\n   if(resError == ERR_FUNCTION_NOT_ALLOWED)\n     {\n      error = \"News Filter cannot access the news server.\\n\" +\n              \"Follow these steps to fix it:\\n\"\n              \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" +\n              \" - go to the \\\"Expert Advisors\\\" tab\\n\" +\n              \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" +\n              \" - add \\\"https://forexsb.com\\\" in a field below.\";\n      return \"\";\n     }\n\n   if(resError != ERR_SUCCESS)\n     {\n      error = StringFormat(\"News Filter connection error! Error code: %d\", resError);\n      return \"\";\n     }\n\n   if(resCode != 200)\n     {\n      error = StringFormat(\"Response code: %d\", resCode);\n      return \"\";\n     }\n\n   isNewsFeedOk = true;\n   return CharArrayToString(resData, 0, ArraySize(resData), CP_UTF8);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nstring GetNewsText(void)\n  {\n   string newsText = \"\\n            ..:: Upcoming News ::..\\n\";\n   if(loadNewsError != \"\") return newsText + loadNewsError;\n\n   const datetime timeNow   = TimeGMT();\n   const datetime timeShift = (datetime) MathRound((TimeLocal() - timeNow) / 3600.0) * 3600;\n   const int      newsCount = ArraySize(newsRecords);\n\n   for(int i = 0, count = 0; i < newsCount && count < News_ViewCount; i += 1)\n     {\n      const NewsRecord newsRecord = newsRecords[i];\n\n      if(newsRecord.time < timeNow - News_AfterHigh * 60 ||\n         !NewsIsAcceptedCurrency(newsRecord) ||\n         !NewsIsAcceptedPriority(newsRecord))\n         continue;\n\n      const string newLine  = count > 0 ? \"\\n\" : \"\";\n      const string newsTime = TimeToString(newsRecord.time + timeShift, TIME_DATE | TIME_MINUTES);\n      const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";\n      const string text     = StringFormat(\"%s%s %s %s %s\", newLine, priority, newsTime,\n                                           newsRecord.currency, newsRecord.title);\n      StringAdd(newsText, text);\n      count += 1;\n     }\n\n   return newsText;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)\n  {\n   for(int i = 0; i < ArraySize(newsCurrencies); i += 1)\n      if(newsCurrencies[i] == newsRecord.currency)\n         return true;\n\n   return false;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool NewsIsAcceptedPriority(const NewsRecord &newsRecord)\n  {\n   return (News_Priority == NewsFilter_HighAndMedium) ||\n          (News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");\n  }\n//+------------------------------------------------------------------+\n//| Gets the index of an active news or -1                           |\n//+------------------------------------------------------------------+\nint NewsFilterActive(void)\n  {\n   if(News_Priority == NewsFilter_Disabled)\n      return -1;\n\n   const datetime timeUtc = TimeGMT();\n   const int      newsLen = ArraySize(newsRecords);\n   for(int i = 0; i < newsLen; i++)\n     {\n      const NewsRecord news = newsRecords[i];\n      if(!NewsIsAcceptedCurrency(news) || !NewsIsAcceptedPriority(news))\n         continue;\n\n      if(news.priority == \"high\" &&\n         news.time - News_BeforeHigh * 60 - 15 <= timeUtc &&\n         news.time + News_AfterHigh  * 60 - 15 >= timeUtc)\n         return i;\n\n      if(news.priority == \"medium\" &&\n         news.time - News_BeforeMedium * 60 - 15 <= timeUtc &&\n         news.time + News_AfterMedium  * 60 - 15 >= timeUtc)\n         return i;\n     }\n\n   return -1;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid ParseNewsCurrenciesText(void)\n  {\n   string parts[], parsed[];\n   const int partsLen = StringSplit(News_Currencies, ',', parts);\n   ArrayResize(parsed, partsLen);\n   int len = 0;\n   for(int i = 0; i < partsLen; i += 1)\n     {\n      string part = parts[i];\n      StringReplace(part, \" \", \"\");\n      if(StringLen(part) > 0)\n        {\n         parsed[i] = part;\n         len += 1;\n        }\n     }\n\n   ArrayResize(newsCurrencies, len);\n   for(int i = 0; i < len; i += 1)\n      newsCurrencies[i] = parsed[i];\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nint GetMagicNumber(const int strategyIndex)\n  {\n   return 1000 * Base_Magic_Number + strategyIndex;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nbool IsOwnDeal(const long dealMagic)\n  {\n   const long minMagicNumber = GetMagicNumber(0);\n   const long maxMagicNumber = GetMagicNumber(strategiesCount);\n   return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nint OrderDirectionToCommand(OrderDirection dir)\n  {\n   return dir == ORDER_DIRECTION_BUY  ? OP_BUY\n        : dir == ORDER_DIRECTION_SELL ? OP_SELL\n                                      : OP_FLAT;\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid InitIndicatorHandlers(void)\n  {\n   TesterHideIndicators(true);\n   // Bollinger Bands (Close, 22, 3.33)\n   indHandlers[0][0][0] = iBands(NULL, 0, 22, 0, 3.33, PRICE_CLOSE);\n   // RVI (60)\n   indHandlers[0][1][0] = iRVI(NULL, 0, 60);\n   // Average True Range (32), Level: 0.0087\n   indHandlers[0][2][0] = iATR(NULL, 0, 32);\n   // Moving Averages Crossover (Simple, Simple, 3, 17)\n   indHandlers[1][0][0] = iMA(NULL, 0, 3, 0, MODE_SMA, PRICE_CLOSE);\n   // Moving Averages Crossover (Simple, Simple, 3, 17)\n   indHandlers[1][0][1] = iMA(NULL, 0, 17, 0, MODE_SMA, PRICE_CLOSE);\n   // Force Index (Simple, 10)\n   indHandlers[1][1][0] = iForce(NULL, 0, 10, MODE_SMA, VOLUME_TICK);\n   // DeMarker (39)\n   indHandlers[1][2][0] = iDeMarker(NULL, 0, 39);\n   // Alligator (Smoothed, Median, 39, 18, 18, 3, 3, 12)\n   indHandlers[1][3][0] = iAlligator(NULL, 0, 39, 18, 18, 3, 3, 12, MODE_SMMA, PRICE_MEDIAN);\n   // Average True Range (38), Level: 0.0038\n   indHandlers[1][4][0] = iATR(NULL, 0, 38);\n   // Pin Bar (5, 34)\n   indHandlers[1][5][0] = -1;\n   // Awesome Oscillator, Level: -0.0005\n   indHandlers[2][0][0] = iAO(NULL, 0);\n   // DeMarker (39), Level: 0.44\n   indHandlers[2][1][0] = iDeMarker(NULL, 0, 39);\n   // Do not Exit\n   indHandlers[2][2][0] = -1;\n   // Directional Indicators (65)\n   indHandlers[3][0][0] = iADX(NULL, 0, 65);\n   // Stochastic (20, 9, 9), Level: 57.9\n   indHandlers[3][1][0] = iStochastic(NULL, 0, 20, 9, 9, MODE_SMA, 0);\n   // Bears Power (60), Level: 0.0078\n   indHandlers[3][2][0] = iBearsPower(NULL, 0, 60);\n   // Long or Short\n   indHandlers[4][0][0] = -1;\n   // RVI (46), Level: -0.06\n   indHandlers[4][1][0] = iRVI(NULL, 0, 46);\n   // Accumulation Distribution\n   indHandlers[4][2][0] = iAD(NULL, 0, VOLUME_TICK);\n   // MACD (Close, 12, 24, 9)\n   indHandlers[4][3][0] = iMACD(NULL, 0, 12, 24, 9, PRICE_CLOSE);\n   // Pin Bar (8, 26)\n   indHandlers[4][4][0] = -1;\n   TesterHideIndicators(false);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid SetSignals(Signal &signalList[])\n  {\n   int i = 0;\n   ArrayResize(signalList, 2 * strategiesCount);\n\n   /*STRATEGY CODE {\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]} */\n   signalList[i++] = GetExitSignal_000();\n   signalList[i++] = GetEntrySignal_000();\n\n   /*STRATEGY CODE {\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]} */\n   signalList[i++] = GetExitSignal_001();\n   signalList[i++] = GetEntrySignal_001();\n\n   /*STRATEGY CODE {\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]} */\n   signalList[i++] = GetExitSignal_002();\n   signalList[i++] = GetEntrySignal_002();\n\n   /*STRATEGY CODE {\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]} */\n   signalList[i++] = GetExitSignal_003();\n   signalList[i++] = GetEntrySignal_003();\n\n   /*STRATEGY CODE {\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]} */\n   signalList[i++] = GetExitSignal_004();\n   signalList[i++] = GetEntrySignal_004();\n\n   if(i != 2 * strategiesCount)\n      ArrayResize(signalList, i);\n  }\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetEntrySignal_000()\n  {\n   // Bollinger Bands (Close, 22, 3.33)\n   double ind0buffer0[]; CopyBuffer(indHandlers[0][0][0], 1, 1, 2, ind0buffer0);\n   double ind0buffer1[]; CopyBuffer(indHandlers[0][0][0], 2, 1, 2, ind0buffer1);\n   double ind0upBand1 = ind0buffer0[1];\n   double ind0dnBand1 = ind0buffer1[1];\n   double ind0upBand2 = ind0buffer0[0];\n   double ind0dnBand2 = ind0buffer1[0];\n   bool   ind0long    = Open(0) < ind0dnBand1 - sigma && Open(1) > ind0dnBand2 + sigma;\n   bool   ind0short   = Open(0) > ind0upBand1 + sigma && Open(1) < ind0upBand2 - sigma;\n   // RVI (60)\n   double ind1buffer[]; CopyBuffer(indHandlers[0][1][0], 0, 1, 3, ind1buffer);\n   double ind1val1  = ind1buffer[2];\n   double ind1val2  = ind1buffer[1];\n   bool   ind1long  = ind1val1 < ind1val2 - sigma;\n   bool   ind1short = ind1val1 > ind1val2 + sigma;\n\n   return CreateEntrySignal(0, ind0long && ind1long, ind0short && ind1short, 265, 227, true, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetExitSignal_000()\n  {\n   // Average True Range (32), Level: 0.0087\n   double ind2buffer[]; CopyBuffer(indHandlers[0][2][0], 0, 1, 3, ind2buffer);\n   double ind2val1  = ind2buffer[2];\n   double ind2val2  = ind2buffer[1];\n   bool   ind2long  = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;\n   bool   ind2short = ind2long;\n\n   return CreateExitSignal(0, ind2long, ind2short, 265, 227, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetEntrySignal_001()\n  {\n   // Moving Averages Crossover (Simple, Simple, 3, 17)\n   double ind0buffer0[]; CopyBuffer(indHandlers[1][0][0], 0, 1, 2, ind0buffer0);\n   double ind0buffer1[]; CopyBuffer(indHandlers[1][0][1], 0, 1, 2, ind0buffer1);\n   double ind0val1  = ind0buffer0[1];\n   double ind0val2  = ind0buffer1[1];\n   bool   ind0long  = ind0val1 < ind0val2 - sigma;\n   bool   ind0short = ind0val1 > ind0val2 + sigma;\n   // Force Index (Simple, 10)\n   double ind1buffer[]; CopyBuffer(indHandlers[1][1][0], 0, 1, 3, ind1buffer);\n   double ind1val1  = ind1buffer[2];\n   bool   ind1long  = ind1val1 < 0 - sigma;\n   bool   ind1short = ind1val1 > 0 + sigma;\n   // DeMarker (39)\n   double ind2buffer[]; CopyBuffer(indHandlers[1][2][0], 0, 1, 3, ind2buffer);\n   double ind2val1  = ind2buffer[2];\n   double ind2val2  = ind2buffer[1];\n   bool   ind2long  = ind2val1 > ind2val2 + sigma;\n   bool   ind2short = ind2val1 < ind2val2 - sigma;\n   // Alligator (Smoothed, Median, 39, 18, 18, 3, 3, 12)\n   double ind3buffer0[]; CopyBuffer(indHandlers[1][3][0], 0, 1, 2, ind3buffer0);\n   double ind3buffer1[]; CopyBuffer(indHandlers[1][3][0], 1, 1, 2, ind3buffer1);\n   double ind3buffer2[]; CopyBuffer(indHandlers[1][3][0], 2, 1, 2, ind3buffer2);\n   double ind3val1  = ind3buffer2[1];\n   double ind3val2  = ind3buffer0[1];\n   double ind3val3  = ind3buffer2[0];\n   double ind3val4  = ind3buffer0[0];\n   bool   ind3long  = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;\n   bool   ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;\n\n   return CreateEntrySignal(1, ind0long && ind1long && ind2long && ind3long, ind0short && ind1short && ind2short && ind3short, 350, 275, true, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetExitSignal_001()\n  {\n   // Average True Range (38), Level: 0.0038\n   double ind4buffer[]; CopyBuffer(indHandlers[1][4][0], 0, 1, 3, ind4buffer);\n   double ind4val1  = ind4buffer[2];\n   bool   ind4long  = ind4val1 > 0.0038 + sigma;\n   bool   ind4short = ind4long;\n   // Pin Bar (5, 34)\n\n   bool ind5long  = false;\n   bool ind5short = false;\n\n   {\n      double closeOpen = MathAbs(Close(1) - Open(1));\n      bool isPinBar = closeOpen < 5 * 0.01 * (High(1) - Low(1));\n      bool upWick   = High(1) - MathMax(Close(1), Open(1)) > 34 * 0.01 * closeOpen;\n      bool downWick = MathMin(Close(1), Open(1)) - Low(1)  > 34 * 0.01 * closeOpen;\n      bool isBearishPinBar = isPinBar && upWick && !downWick;\n      bool isBullishPinBar = isPinBar && downWick && !upWick;\n\n      ind5long  = isBullishPinBar;\n      ind5short = isBearishPinBar;\n   }\n\n   return CreateExitSignal(1, ind4long || ind5long, ind4short || ind5short, 350, 275, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetEntrySignal_002()\n  {\n   // Awesome Oscillator, Level: -0.0005\n   double ind0buffer[]; CopyBuffer(indHandlers[2][0][0], 0, 1, 3, ind0buffer);\n   double ind0val1  = ind0buffer[2];\n   double ind0val2  = ind0buffer[1];\n   bool   ind0long  = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;\n   bool   ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;\n   // DeMarker (39), Level: 0.44\n   double ind1buffer[]; CopyBuffer(indHandlers[2][1][0], 0, 1, 3, ind1buffer);\n   double ind1val1  = ind1buffer[2];\n   double ind1val2  = ind1buffer[1];\n   bool   ind1long  = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;\n   bool   ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;\n\n   return CreateEntrySignal(2, ind0long && ind1long, ind0short && ind1short, 189, 78, true, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetExitSignal_002()\n  {\n   // Do not Exit\n   bool ind2long  = false;\n   bool ind2short = false;\n\n   return CreateExitSignal(2, ind2long, ind2short, 189, 78, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetEntrySignal_003()\n  {\n   // Directional Indicators (65)\n   double ind0buffer0[]; CopyBuffer(indHandlers[3][0][0], 1, 1, 2, ind0buffer0);\n   double ind0buffer1[]; CopyBuffer(indHandlers[3][0][0], 2, 1, 2, ind0buffer1);\n   double ind0val1  = ind0buffer0[1];\n   double ind0val2  = ind0buffer1[1];\n   double ind0val3  = ind0buffer0[0];\n   double ind0val4  = ind0buffer1[0];\n   bool   ind0long  = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;\n   bool   ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;\n   // Stochastic (20, 9, 9), Level: 57.9\n   double ind1buffer[]; CopyBuffer(indHandlers[3][1][0], MAIN_LINE, 1, 3, ind1buffer);\n   double ind1val1  = ind1buffer[2];\n   double ind1val2  = ind1buffer[1];\n   bool   ind1long  = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;\n   bool   ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;\n\n   return CreateEntrySignal(3, ind0long && ind1long, ind0short && ind1short, 364, 445, false, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetExitSignal_003()\n  {\n   // Bears Power (60), Level: 0.0078\n   double ind2buffer[]; CopyBuffer(indHandlers[3][2][0], 0, 1, 3, ind2buffer);\n   double ind2val1  = ind2buffer[2];\n   bool   ind2long  = ind2val1 > 0.0078 + sigma;\n   bool   ind2short = ind2val1 < -0.0078 - sigma;\n\n   return CreateExitSignal(3, ind2long, ind2short, 364, 445, false);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetEntrySignal_004()\n  {\n   // Long or Short\n   bool ind0long  = true;\n   bool ind0short = false;\n   // RVI (46), Level: -0.06\n   double ind1buffer[]; CopyBuffer(indHandlers[4][1][0], 0, 1, 3, ind1buffer);\n   double ind1val1  = ind1buffer[2];\n   double ind1val2  = ind1buffer[1];\n   bool   ind1long  = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;\n   bool   ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;\n   // Accumulation Distribution\n   double ind2buffer[]; CopyBuffer(indHandlers[4][2][0], 0, 1, 3, ind2buffer);\n   double ind2val1  = ind2buffer[2];\n   double ind2val2  = ind2buffer[1];\n   bool   ind2long  = ind2val1 > ind2val2 + sigma;\n   bool   ind2short = ind2val1 < ind2val2 - sigma;\n   // MACD (Close, 12, 24, 9)\n   double ind3buffer[]; CopyBuffer(indHandlers[4][3][0], 0, 1, 3, ind3buffer);\n   double ind3val1  = ind3buffer[2];\n   double ind3val2  = ind3buffer[1];\n   bool   ind3long  = ind3val1 < ind3val2 - sigma;\n   bool   ind3short = ind3val1 > ind3val2 + sigma;\n\n   return CreateEntrySignal(4, ind0long && ind1long && ind2long && ind3long, ind0short && ind1short && ind2short && ind3short, 85, 104, false, true);\n  }\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nSignal GetExitSignal_004()\n  {\n   // Pin Bar (8, 26)\n\n   bool ind4long  = false;\n   bool ind4short = false;\n\n   {\n      double closeOpen = MathAbs(Close(1) - Open(1));\n      bool isPinBar = closeOpen < 8 * 0.01 * (High(1) - Low(1));\n      bool upWick   = High(1) - MathMax(Close(1), Open(1)) > 26 * 0.01 * closeOpen;\n      bool downWick = MathMin(Close(1), Open(1)) - Low(1)  > 26 * 0.01 * closeOpen;\n      bool isBearishPinBar = isPinBar && upWick && !downWick;\n      bool isBullishPinBar = isPinBar && downWick && !upWick;\n\n      ind4long  = isBullishPinBar;\n      ind4short = isBearishPinBar;\n   }\n\n   return CreateExitSignal(4, ind4long, ind4short, 85, 104, false);\n  }\n//+------------------------------------------------------------------+\n/*STRATEGY MARKET XMGlobal-MT5 13; USDCAD; M15 */\n",
  "profile": {
    "description": "Expert Advisor imported from MQL code",
    "execution_status": "stopped",
    "indicators": [
      "Bears Power",
      "Moving Average",
      "MACD",
      "Bollinger Bands",
      "Stochastic",
      "ADX",
      "ATR",
      "DeMarker",
      "RVI",
      "Awesome Oscillator",
      "Force Index",
      "Alligator",
      "On Balance Volume",
      "Accumulation/Distribution"
    ],
    "magic_numbers": [
      100,
      100000,
      100001,
      100002,
      100003,
      100004
    ],
    "name": "StormTiger D1-100",
    "parameters": [
      {
        "default_value": 0.01,
        "description": "double parameter",
        "max_value": null,
        "min_value": null,
        "name": "Entry_Amount",
        "step": null,
        "type": "double"
      },
      {
        "default_value": 100,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "Base_Magic_Number",
        "step": null,
        "type": "int"
      },
      {
        "default_value": "------",
        "description": "string parameter",
        "max_value": null,
        "min_value": null,
        "name": "Entry_prot__",
        "step": null,
        "type": "string"
      },
      {
        "default_value": 0,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "Max_Spread",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 90,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "Max_OpenPos",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 1,
        "description": "double parameter",
        "max_value": null,
        "min_value": null,
        "name": "Max_OpenLots",
        "step": null,
        "type": "double"
      },
      {
        "default_value": "------",
        "description": "string parameter",
        "max_value": null,
        "min_value": null,
        "name": "Daily_prot__",
        "step": null,
        "type": "string"
      },
      {
        "default_value": 1,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "MaxDailyLoss",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 5,
        "description": "double parameter",
        "max_value": null,
        "min_value": null,
        "name": "Max_Daily_DD",
        "step": null,
        "type": "double"
      },
      {
        "default_value": 0,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "Daily_Reset",
        "step": null,
        "type": "int"
      },
      {
        "default_value": "------",
        "description": "string parameter",
        "max_value": null,
        "min_value": null,
        "name": "Account_prot",
        "step": null,
        "type": "string"
      },
      {
        "default_value": 500,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "Min_Equity",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 5,
        "description": "double parameter",
        "max_value": null,
        "min_value": null,
        "name": "MaxEquity_DD",
        "step": null,
        "type": "double"
      },
      {
        "default_value": 100000,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "Max_Equity",
        "step": null,
        "type": "int"
      },
      {
        "default_value": "------",
        "description": "string parameter",
        "max_value": null,
        "min_value": null,
        "name": "_NewsFilter_",
        "step": null,
        "type": "string"
      },
      {
        "default_value": "NewsFilter_HighOnly",
        "description": "NewsFilterPriority parameter",
        "max_value": null,
        "min_value": null,
        "name": "News_Priority",
        "step": null,
        "type": "NewsFilterPriority"
      },
      {
        "default_value": "USD,CAD,EUR",
        "description": "string parameter",
        "max_value": null,
        "min_value": null,
        "name": "News_Currencies",
        "step": null,
        "type": "string"
      },
      {
        "default_value": 2,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "News_BeforeMedium",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 2,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "News_AfterMedium",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 2,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "News_BeforeHigh",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 5,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "News_AfterHigh",
        "step": null,
        "type": "int"
      },
      {
        "default_value": 10,
        "description": "int parameter",
        "max_value": null,
        "min_value": null,
        "name": "News_ViewCount",
        "step": null,
        "type": "int"
      },
      {
        "default_value": "------",
        "description": "string parameter",
        "max_value": null,
        "min_value": null,
        "name": "__Stats_____",
        "step": null,
        "type": "string"
      },
      {
        "default_value": true,
        "description": "bool parameter",
        "max_value": null,
        "min_value": null,
        "name": "Pos_Stat",
        "step": null,
        "type": "bool"
      },
      {
        "default_value": true,
        "description": "bool parameter",
        "max_value": null,
        "min_value": null,
        "name": "Robot_Stats",
        "step": null,
        "type": "bool"
      }
    ],
    "symbols": [
      "GET",
      "RVI",
      "MACD"
    ],
    "timeframes": [
      "D1"
    ],
    "trading_rules": [
      {
        "actions": [
          "OrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/"
        ],
        "direction": "both",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "OrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/"
        ],
        "direction": "both",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "OrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/"
        ],
        "direction": "both",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "OrderSend(request,result)"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/"
        ],
        "direction": "both",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "OrderSend(request,result)"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/"
        ],
        "direction": "both",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "Generated signal: BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecord{datetime time;string priority;string currency;string title;};NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScope{ORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/",
          "Signal: BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecord{datetime time;string priority;string currency;string title;};NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScope{ORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "direction": "buy",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "Generated signal: SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecord{datetime time;string priority;string currency;string title;};NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScope{ORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/",
          "Signal: SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecord{datetime time;string priority;string currency;string title;};NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScope{ORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "direction": "sell",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "Generated signal: long Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/",
          "Signal: long Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "direction": "buy",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "Generated signal: Short,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/",
          "Signal: Short,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "direction": "sell",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "entry"
      },
      {
        "actions": [
          "Generated signal: Close = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecord{datetime time;string priority;string currency;string title;};NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScope{ORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/",
          "Signal: Close = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecord{datetime time;string priority;string currency;string title;};NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScope{ORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "direction": "both",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "exit"
      },
      {
        "actions": [
          "Generated signal: EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "conditions": [
          "#property copyright \"Forex Software Ltd.\" #property version \"4.2\" #property strict static input double Entry_Amount = 0.01;static input int Base_Magic_Number = 100;static input string Entry_prot__ = \"------\";static input int Max_Spread = 0;static input int Max_OpenPos = 90;static input double Max_OpenLots = 1.00;static input string Daily_prot__ = \"------\";static input int MaxDailyLoss = 1;static input double Max_Daily_DD = 5.00;static input int Daily_Reset = 0;static input string Account_prot = \"------\";static input int Min_Equity = 500;static input double MaxEquity_DD = 5.00;static input int Max_Equity = 100000;static input string _NewsFilter_ = \"------\";enum NewsFilterPriorityNewsFilter_Disabled,NewsFilter_HighOnly,NewsFilter_HighAndMedium;static input NewsFilterPriority News_Priority = NewsFilter_HighOnly;static input string News_Currencies = \"USD,CAD,EUR\";static input int News_BeforeMedium = 2;static input int News_AfterMedium = 2;static input int News_BeforeHigh = 2;static input int News_AfterHigh = 5;static input int News_ViewCount = 10;static input string __Stats_____ = \"------\";static input bool Pos_Stat = true;static input bool Robot_Stats = true;#define TRADE_RETRY_COUNT 4 #define TRADE_RETRY_WAIT 100 #define OP_FLAT -1 #define OP_BUY ORDER_TYPE_BUY #define OP_SELL ORDER_TYPE_SELL string robotTagline = \"A Portfolio Expert from Expert Advisor Studio\";const int sessionSundayOpen = 0;const int sessionSundayClose = 86400;const int sessionMondayThursdayOpen = 0;const int sessionMondayThursdayClose = 86400;const int sessionFridayOpen = 0;const int sessionFridayClose = 86400;const bool sessionIgnoreSunday = false;const bool sessionCloseAtSessionClose = false;const bool sessionCloseAtFridayClose = false;const int strategiesCount = 5;const double sigma = 0.000001;const int requiredBars = 100;datetime lastStatsUpdate = 0;datetime barTime;double stopLevel;double pip;bool setProtectionSeparately = false;int indHandlers[5][12][2];int maxRectangles = 0;int maxLabels = 0;int posStatCount = 0;double posStatLots = 0;double posStatProfit = 0;string accountProtectionMessage = \"\";string entryProtectionMessage = \"\";struct NewsRecorddatetime time;string priority;string currency;string title;;NewsRecord newsRecords[];string newsCurrencies[];datetime lastNewsUpdate = 0;string loadNewsError = \"\";bool isNewsFeedOk = true;string accMaxEquityGlobalVarName = \"accMaxEquity123456789\";string accMaxDailyBalanceGlobalVarName = \"accMaxDailyBalance123456789\";string accMaxDailyEquityGlobalVarName = \"accMaxDailyEquity123456789\";string accEntrySuspendGlobalVarName = \"accEntrySuspend123456789\";double equityDrawdownPercent = 0;datetime dailyDrawdownLastReset = 0;double dailyLoss = 0;double dailyDrawdown = 0;ENUM_ORDER_TYPE_FILLING orderFillingType = ORDER_FILLING_FOK;enum OrderScopeORDER_SCOPE_UNDEFINED,ORDER_SCOPE_ENTRY,ORDER_SCOPE_EXIT;enum OrderDirectionORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH;struct Positionint Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;;struct Signalint MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;;int OnInit()Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;void OnDeinit(const int reason)DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);void OnTick(void)if(!MQLInfoInteger(MQL_TESTER))UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3)lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk)lastNewsUpdate = time;LoadNews();if(IsForceSessionClose())CloseAllPositions();return;const datetime time = Time(0);if(time > barTime)barTime = time;OnBar();void OnBar(void)if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);void ManageSignal(Signal &signal)Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT)if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);return;if(signal.IsTrailingStop)double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);if(position.Type != OP_FLAT && signal.OppositeReverse)if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY))ClosePosition(position);ManageSignal(signal);return;if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);int CountPositions(void)const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol)const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;return count;Position CreatePosition(const int magicNumber)Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1)const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber)position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;return position;Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop)Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;void OpenPosition(Signal &signal)entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1)const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);if(entryProtectionMessage != \"\")entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber))posStatCount += 1;posStatLots += posLots;void ClosePosition(Position &position)const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber))posStatCount -= 1;posStatLots -= position.Lots;void CloseAllPositions(void)for(int i = 0;i < strategiesCount;i += 1)const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));return false;void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber)for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++)if(IsTradeContextFree())MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck)ResetLastError();isOrderSend = OrderSend(request,result);if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));bool CheckOrder(MqlTradeRequest &request)MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL)switch(orderFillingType)case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;request.type_filling = orderFillingType;return CheckOrder(request);return false;double GetStopLossPrice(const int command,const int stopLossPips)if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);double GetTakeProfitPrice(const int command,const int takeProfitPips)if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);double GetTrailingStopPrice(Position &position,const int stopLoss)const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY)const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;if(position.Type == OP_SELL)const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;return position.StopLoss;void ManageTrailingStop(Position &position,const double trailingStop)if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point))ClosePosition(position);return;if(MathAbs(trailingStop - position.StopLoss)> _Point)position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);double Bid(void)return SymbolInfoDouble(_Symbol,SYMBOL_BID);double Ask(void)return SymbolInfoDouble(_Symbol,SYMBOL_ASK);datetime Time(const int bar)datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Open(const int bar)double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double High(const int bar)double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Low(const int bar)double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double Close(const int bar)double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;double GetPipValue(void)return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;bool IsTradeAllowed(void)return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);void RefreshRates(void)int DayOfWeek(void)MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;bool IsTradeContextFree(void)if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true)if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000)Print(\"The waiting limit exceeded!\");return false;if(IsTradeAllowed())RefreshRates();return true;Sleep(TRADE_RETRY_WAIT);return true;bool IsOutOfSession(void)const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;bool IsForceSessionClose(void)if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;void UpdateAccountProtection(void)const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity)maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60)dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;void CheckAccountProtection(void)const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity)ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;if(Max_Equity > sigma && accountEquity >= Max_Equity)ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD)ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;void ActivateProtection(const string message)CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);void SetPosStats(void)posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1)const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);void UpdateStats(void)string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);string GetProtectionInfo(void)string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;string GetPositionStats(void)return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");string GetRobotStats(void)return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);string GetRobotStatsDays(const int days)double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1)const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);string GetNewsInfo(void)return \"\";void RenderStats(const string text)string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1)if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0)if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0)if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);void LabelUpdate(int chartId,string name,string text)ObjectSetString(chartId,name,OBJPROP_TEXT,text);color GetChartForeColor(const long chartId=0)long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;color GetChartBackColor(const long chartId=0)long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;void DeleteObjects(void)if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++)const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);maxRectangles = 0;maxLabels = 0;void InitGlobalVariables(void)if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);void LoadNews(void)loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\")loadNewsError = error;return;if(newsContent == \"\")loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;void ParseNewsContent(const string newsContent,string &error)string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1)error = \"Cannot parse the news feed\";return;ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1)string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4)error = \"Cannot parse the news feed records\";return;NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;string GetNewsContent(string &error)const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED)error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";if(resError != ERR_SUCCESS)error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";if(resCode != 200)error = StringFormat(\"Response code: %d\",resCode);return \"\";isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);string GetNewsText(void)string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1)const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;return newsText;bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord)for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;bool NewsIsAcceptedPriority(const NewsRecord &newsRecord)return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");int NewsFilterActive(void)if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++)const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;return -1;void ParseNewsCurrenciesText(void)string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1)string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0)parsed[i] = part;len += 1;ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];int GetMagicNumber(const int strategyIndex)return 1000 * Base_Magic_Number + strategyIndex;bool IsOwnDeal(const long dealMagic)const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;int OrderDirectionToCommand(OrderDirection dir)return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;void InitIndicatorHandlers(void)TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);void SetSignals(Signal &signalList[])int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);Signal GetEntrySignal_000()double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);Signal GetExitSignal_000()double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);Signal GetEntrySignal_001()double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);Signal GetExitSignal_001()double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);Signal GetEntrySignal_002()double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);Signal GetExitSignal_002()bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);Signal GetEntrySignal_003()double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);Signal GetExitSignal_003()double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);Signal GetEntrySignal_004()bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);Signal GetExitSignal_004()bool ind4long = false;bool ind4short = false;double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;return CreateExitSignal(4,ind4long,ind4short,85,104,false);/*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0],\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0],\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]],\"closeFilters\":[\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0],\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true,\"openFilters\":[\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0],\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]],\"closeFilters\":[\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0],\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]],\"closeFilters\":[\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]]*/ /*STRATEGY CODE\"properties\":\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false,\"openFilters\":[\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0],\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0],\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]],\"closeFilters\":[\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]]*/",
          "Signal: EXIT};enum OrderDirection{ORDER_DIRECTION_NONE,ORDER_DIRECTION_BUY,ORDER_DIRECTION_SELL,ORDER_DIRECTION_BOTH};struct Position{int Type;ulong Ticket;int MagicNumber;double Lots;double Price;double StopLoss;double TakeProfit;};struct Signal{int MagicNumber;OrderScope Scope;OrderDirection Direction;int StopLossPips;int TakeProfitPips;bool IsTrailingStop;bool OppositeReverse;};int OnInit(){Comment(\"\");DeleteObjects();barTime = Time(0);stopLevel =(int)SymbolInfoInteger(_Symbol,SYMBOL_TRADE_STOPS_LEVEL);pip = GetPipValue();accountProtectionMessage = \"\";entryProtectionMessage = \"\";InitIndicatorHandlers();ParseNewsCurrenciesText();lastNewsUpdate = TimeCurrent();if(!MQLInfoInteger(MQL_TESTER))LoadNews();OnTick();ChartRedraw(0);return INIT_SUCCEEDED;}void OnDeinit(const int reason){DeleteObjects();if(accountProtectionMessage != \"\")Comment(accountProtectionMessage);}void OnTick(void){if(!MQLInfoInteger(MQL_TESTER)){UpdateAccountProtection();CheckAccountProtection();const datetime time = TimeCurrent();if(time > lastStatsUpdate + 3){lastStatsUpdate = time;if(Max_OpenPos > sigma || Max_OpenLots > sigma)SetPosStats();UpdateStats();}if(time > lastNewsUpdate + 6*60*60 || !isNewsFeedOk){lastNewsUpdate = time;LoadNews();}}if(IsForceSessionClose()){CloseAllPositions();return;}const datetime time = Time(0);if(time > barTime){barTime = time;OnBar();}}void OnBar(void){if(IsOutOfSession())return;if(Max_OpenPos || Max_OpenLots)SetPosStats();Signal signalList[];SetSignals(signalList);int signalsCount = ArraySize(signalList);for(int i = 0;i < signalsCount;i += 1)ManageSignal(signalList[i]);}void ManageSignal(Signal &signal){Position position = CreatePosition(signal.MagicNumber);if(position.Type != OP_FLAT && signal.Scope == ORDER_SCOPE_EXIT){if((signal.Direction == ORDER_DIRECTION_BOTH)||(position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);return;}if(signal.IsTrailingStop){double trailingStop = GetTrailingStopPrice(position,signal.StopLossPips);ManageTrailingStop(position,trailingStop);}}if(position.Type != OP_FLAT && signal.OppositeReverse){if((position.Type == OP_BUY && signal.Direction == ORDER_DIRECTION_SELL)||(position.Type == OP_SELL && signal.Direction == ORDER_DIRECTION_BUY)){ClosePosition(position);ManageSignal(signal);return;}}if((position.Type == OP_FLAT && signal.Scope == ORDER_SCOPE_ENTRY)&&(signal.Direction == ORDER_DIRECTION_BUY || signal.Direction == ORDER_DIRECTION_SELL))OpenPosition(signal);}int CountPositions(void){const int minMagic = GetMagicNumber(0);const int maxMagic = GetMagicNumber(strategiesCount);const int posTotal = PositionsTotal();int count = 0;for(int posIndex = posTotal - 1;posIndex >= 0;posIndex--){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol){const long magicNumber = PositionGetInteger(POSITION_MAGIC);if(magicNumber >= minMagic && magicNumber <= maxMagic)count += 1;}}return count;}Position CreatePosition(const int magicNumber){Position position;position.MagicNumber = magicNumber;position.Type = OP_FLAT;position.Ticket = 0;position.Lots = 0;position.Price = 0;position.StopLoss = 0;position.TakeProfit = 0;const int posTotal = PositionsTotal();for(int posIndex = 0;posIndex < posTotal;posIndex += 1){const ulong ticket = PositionGetTicket(posIndex);if(PositionSelectByTicket(ticket)&& PositionGetString(POSITION_SYMBOL)== _Symbol && PositionGetInteger(POSITION_MAGIC)== magicNumber){position.Type =(int)PositionGetInteger(POSITION_TYPE);position.Ticket = ticket;position.Lots = NormalizeDouble(PositionGetDouble(POSITION_VOLUME),2);position.Price = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);position.StopLoss = NormalizeDouble(PositionGetDouble(POSITION_SL),_Digits);position.TakeProfit = NormalizeDouble(PositionGetDouble(POSITION_TP),_Digits);break;}}return position;}Signal CreateEntrySignal(int strategyIndex,bool canOpenLong,bool canOpenShort,int stopLossPips,int takeProfitPips,bool isTrailingStop,bool oppositeReverse = false){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_ENTRY;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = oppositeReverse;signal.Direction = canOpenLong && canOpenShort ? ORDER_DIRECTION_BOTH : canOpenLong ? ORDER_DIRECTION_BUY : canOpenShort ? ORDER_DIRECTION_SELL : ORDER_DIRECTION_NONE;return signal;}Signal CreateExitSignal(int strategyIndex,bool canCloseLong,bool canCloseShorts,int stopLossPips,int takeProfitPips,bool isTrailingStop){Signal signal;signal.MagicNumber = GetMagicNumber(strategyIndex);signal.Scope = ORDER_SCOPE_EXIT;signal.StopLossPips = stopLossPips;signal.TakeProfitPips = takeProfitPips;signal.IsTrailingStop = isTrailingStop;signal.OppositeReverse = false;signal.Direction = canCloseLong && canCloseShorts ? ORDER_DIRECTION_BOTH : canCloseLong ? ORDER_DIRECTION_SELL : canCloseShorts ? ORDER_DIRECTION_BUY : ORDER_DIRECTION_NONE;return signal;}void OpenPosition(Signal &signal){entryProtectionMessage = \"\";const int spread =(int)((Ask()- Bid())/ _Point);if(Max_OpenPos > sigma && posStatCount >= Max_OpenPos)entryProtectionMessage += StringFormat(\"Protection: Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma && posStatLots > Max_OpenLots - sigma)entryProtectionMessage += StringFormat(\"Protection: Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(Max_Spread > sigma && spread > Max_Spread)entryProtectionMessage += StringFormat(\"Protection: Max spread: %d,current: %d\\n\",Max_Spread,spread);if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss)entryProtectionMessage += StringFormat(\"Protection: Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD)entryProtectionMessage += StringFormat(\"Protection: Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(GlobalVariableGet(accEntrySuspendGlobalVarName)> sigma)entryProtectionMessage += StringFormat(\"New entries are suspended until the Daily reset hour: %d\",Daily_Reset);const int newsIndex = NewsFilterActive();if(newsIndex > -1){const NewsRecord newsRecord = newsRecords[newsIndex];const datetime timeShift =(datetime)MathRound((TimeLocal()- TimeGMT())/ 3600.0)* 3600;const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";entryProtectionMessage += StringFormat(\"News filter: %s %s %s %s\\n\",priority,TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES),newsRecord.currency,newsRecord.title);}if(entryProtectionMessage != \"\"){entryProtectionMessage = TimeToString(TimeCurrent())+ \" \" + \"An entry order was canceled:\\n\" + entryProtectionMessage;return;}const int command = OrderDirectionToCommand(signal.Direction);const double stopLoss = GetStopLossPrice(command,signal.StopLossPips);const double takeProfit = GetTakeProfitPrice(command,signal.TakeProfitPips);const double posLots = Entry_Amount;if(ManageOrderSend(command,posLots,stopLoss,takeProfit,0,signal.MagicNumber)){posStatCount += 1;posStatLots += posLots;}}void ClosePosition(Position &position){const int command = position.Type == OP_BUY ? OP_SELL : OP_BUY;if(ManageOrderSend(command,position.Lots,0,0,position.Ticket,position.MagicNumber)){posStatCount -= 1;posStatLots -= position.Lots;}}void CloseAllPositions(void){for(int i = 0;i < strategiesCount;i += 1){const int magicNumber = GetMagicNumber(i);Position position = CreatePosition(magicNumber);if(position.Type == OP_BUY || position.Type == OP_SELL)ClosePosition(position);}}bool ManageOrderSend(int command,double lots,double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_DEAL;request.symbol = _Symbol;request.volume = lots;request.type = command == OP_BUY ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;request.price = command == OP_BUY ? Ask(): Bid();request.type_filling = orderFillingType;request.deviation = 10;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return true;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}return false;}void ModifyPosition(double stopLoss,double takeProfit,ulong ticket,int magicNumber){for(int attempt = 0;attempt < TRADE_RETRY_COUNT;attempt++){if(IsTradeContextFree()){MqlTradeRequest request;MqlTradeResult result;ZeroMemory(request);ZeroMemory(result);request.action = TRADE_ACTION_SLTP;request.symbol = _Symbol;request.sl = stopLoss;request.tp = takeProfit;request.magic = magicNumber;request.position = ticket;request.comment = IntegerToString(magicNumber);bool isOrderCheck = CheckOrder(request);bool isOrderSend = false;if(isOrderCheck){ResetLastError();isOrderSend = OrderSend(request,result);}if(isOrderCheck && isOrderSend && result.retcode == TRADE_RETCODE_DONE)return;}Sleep(TRADE_RETRY_WAIT);Print(\"Order Send retry: \" + IntegerToString(attempt + 2));}}bool CheckOrder(MqlTradeRequest &request){MqlTradeCheckResult check;ZeroMemory(check);ResetLastError();if(OrderCheck(request,check))return true;Print(\"Error with OrderCheck: \" + check.comment);if(check.retcode == TRADE_RETCODE_INVALID_FILL){switch(orderFillingType){case ORDER_FILLING_FOK: Print(\"Filling mode changed to: ORDER_FILLING_IOC\");orderFillingType = ORDER_FILLING_IOC;break;case ORDER_FILLING_IOC: Print(\"Filling mode changed to: ORDER_FILLING_RETURN\");orderFillingType = ORDER_FILLING_RETURN;break;case ORDER_FILLING_RETURN: Print(\"Filling mode changed to: ORDER_FILLING_FOK\");orderFillingType = ORDER_FILLING_FOK;break;}request.type_filling = orderFillingType;return CheckOrder(request);}return false;}double GetStopLossPrice(const int command,const int stopLossPips){if(stopLossPips == 0)return 0;const double delta = MathMax(pip * stopLossPips,_Point * stopLevel);const double stopLoss = command == OP_BUY ? Bid()- delta : Ask()+ delta;return NormalizeDouble(stopLoss,_Digits);}double GetTakeProfitPrice(const int command,const int takeProfitPips){if(takeProfitPips == 0)return 0;const double delta = MathMax(pip * takeProfitPips,_Point * stopLevel);const double takeProfit = command == OP_BUY ? Bid()+ delta : Ask()- delta;return NormalizeDouble(takeProfit,_Digits);}double GetTrailingStopPrice(Position &position,const int stopLoss){const double bid = Bid();const double ask = Ask();const double spread = ask - bid;const double stopLevelPoints = _Point * stopLevel;const double stopLossPoints = pip * stopLoss;if(position.Type == OP_BUY){const double newStopLoss = High(1)- stopLossPoints;if(position.StopLoss <= newStopLoss - pip)return newStopLoss < bid ? newStopLoss >= bid - stopLevelPoints ? bid - stopLevelPoints : newStopLoss : bid;}if(position.Type == OP_SELL){const double newStopLoss = Low(1)+ spread + stopLossPoints;if(position.StopLoss >= newStopLoss + pip)return newStopLoss > ask ? newStopLoss <= ask + stopLevelPoints ? ask + stopLevelPoints : newStopLoss : ask;}return position.StopLoss;}void ManageTrailingStop(Position &position,const double trailingStop){if((position.Type == OP_BUY && MathAbs(trailingStop - Bid())< _Point)||(position.Type == OP_SELL && MathAbs(trailingStop - Ask())< _Point)){ClosePosition(position);return;}if(MathAbs(trailingStop - position.StopLoss)> _Point){position.StopLoss = NormalizeDouble(trailingStop,_Digits);ModifyPosition(position.StopLoss,position.TakeProfit,position.Ticket,position.MagicNumber);}}double Bid(void){return SymbolInfoDouble(_Symbol,SYMBOL_BID);}double Ask(void){return SymbolInfoDouble(_Symbol,SYMBOL_ASK);}datetime Time(const int bar){datetime buffer[];ArrayResize(buffer,1);return CopyTime(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Open(const int bar){double buffer[];ArrayResize(buffer,1);return CopyOpen(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double High(const int bar){double buffer[];ArrayResize(buffer,1);return CopyHigh(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Low(const int bar){double buffer[];ArrayResize(buffer,1);return CopyLow(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double Close(const int bar){double buffer[];ArrayResize(buffer,1);return CopyClose(_Symbol,_Period,bar,1,buffer)== 1 ? buffer[0] : 0;}double GetPipValue(void){return _Digits == 4 || _Digits == 5 ? 0.0001 : _Digits == 2 || _Digits == 3 ? 0.01 : _Digits == 1 ? 0.1 : 1;}bool IsTradeAllowed(void){return(bool)MQL5InfoInteger(MQL5_TRADE_ALLOWED);}void RefreshRates(void){}int DayOfWeek(void){MqlDateTime mqlTime;TimeToStruct(Time(0),mqlTime);return mqlTime.day_of_week;}bool IsTradeContextFree(void){if(IsTradeAllowed())return true;const uint startWait = GetTickCount();Print(\"Trade context is busy! Waiting...\");while(true){if(IsStopped())return false;const uint diff = GetTickCount()- startWait;if(diff > 30 * 1000){Print(\"The waiting limit exceeded!\");return false;}if(IsTradeAllowed()){RefreshRates();return true;}Sleep(TRADE_RETRY_WAIT);}return true;}bool IsOutOfSession(void){const int dayOfWeek = DayOfWeek();const int periodStart = int(Time(0)% 86400);const int periodLength = PeriodSeconds(_Period);const int periodFix = periodStart +(sessionCloseAtSessionClose ? periodLength : 0);const int friBarFix = periodStart +(sessionCloseAtFridayClose || sessionCloseAtSessionClose ? periodLength : 0);return dayOfWeek == 0 && sessionIgnoreSunday ? true : dayOfWeek == 0 ? periodStart < sessionSundayOpen || periodFix > sessionSundayClose : dayOfWeek < 5 ? periodStart < sessionMondayThursdayOpen || periodFix > sessionMondayThursdayClose : periodStart < sessionFridayOpen || friBarFix > sessionFridayClose;}bool IsForceSessionClose(void){if(!sessionCloseAtFridayClose && !sessionCloseAtSessionClose)return false;const int dayOfWeek = DayOfWeek();const int periodEnd = int(Time(0)% 86400)+ PeriodSeconds(_Period);return dayOfWeek == 0 && sessionCloseAtSessionClose ? periodEnd > sessionSundayClose : dayOfWeek < 5 && sessionCloseAtSessionClose ? periodEnd > sessionMondayThursdayClose : dayOfWeek == 5 ? periodEnd > sessionFridayClose : false;}void UpdateAccountProtection(void){const double equity = AccountInfoDouble(ACCOUNT_EQUITY);double maxEquity = GlobalVariableGet(accMaxEquityGlobalVarName);if(equity > maxEquity){maxEquity = equity;GlobalVariableSet(accMaxEquityGlobalVarName,maxEquity);}equityDrawdownPercent = 100 *(maxEquity - equity)/ maxEquity;if(equity > GlobalVariableGet(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);const double balance = AccountInfoDouble(ACCOUNT_BALANCE);if(balance > GlobalVariableGet(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);double maxDailyBalance = GlobalVariableGet(accMaxDailyBalanceGlobalVarName);double maxDailyEquity = GlobalVariableGet(accMaxDailyEquityGlobalVarName);const datetime currentTime = TimeCurrent();MqlDateTime dateTime;TimeToStruct(currentTime,dateTime);if(dateTime.hour == Daily_Reset && currentTime - dailyDrawdownLastReset > 60 * 60){dailyDrawdownLastReset = currentTime;GlobalVariableSet(accMaxDailyEquityGlobalVarName,equity);GlobalVariableSet(accMaxDailyBalanceGlobalVarName,balance);GlobalVariableSet(accEntrySuspendGlobalVarName,0);maxDailyBalance = balance;maxDailyEquity = equity;entryProtectionMessage = \"\";}dailyLoss = equity >= maxDailyBalance ? 0 : maxDailyBalance - equity;dailyDrawdown = 100 *(maxDailyEquity - equity)/ maxDailyEquity;}void CheckAccountProtection(void){const double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);if(Min_Equity > sigma && accountEquity <= Min_Equity){ActivateProtection(StringFormat(\"Minimum equity protection activated. Equity: %.2f\",accountEquity));return;}if(Max_Equity > sigma && accountEquity >= Max_Equity){ActivateProtection(StringFormat(\"Maximum equity protection activated. Equity: %.2f\",accountEquity));return;}if(MaxEquity_DD > sigma && equityDrawdownPercent >= MaxEquity_DD){ActivateProtection(StringFormat(\"Max Equity DD protection activated! Equity DD: %.2f%%\",equityDrawdownPercent));return;}if(MaxDailyLoss > sigma && dailyLoss >= MaxDailyLoss){entryProtectionMessage = StringFormat(\"Max daily loss protection activated! Daily loss: %.2f\\n\",dailyLoss);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}if(Max_Daily_DD > sigma && dailyDrawdown >= Max_Daily_DD){entryProtectionMessage = StringFormat(\"Max daily drawdown protection activated! Daily DD: %.2f%%\\n\",dailyDrawdown);GlobalVariableSet(accEntrySuspendGlobalVarName,1);CloseAllPositions();return;}}void ActivateProtection(const string message){CloseAllPositions();DeleteObjects();accountProtectionMessage = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);accountProtectionMessage += message + \"\\n\";accountProtectionMessage += \"The current positions were closed.\" + \"\\n\";accountProtectionMessage += \"The Portfolio Expert was turned off.\";Comment(accountProtectionMessage);Print(accountProtectionMessage);Sleep(20 * 1000);ExpertRemove();OnDeinit(0);}void SetPosStats(void){posStatCount = 0;posStatLots = 0;posStatProfit = 0;for(int i = PositionsTotal()- 1;i >= 0;i -= 1){const ulong ticket = PositionGetTicket(i);if(ticket == 0 || !PositionSelectByTicket(ticket))continue;const string posSymbol = PositionGetString(POSITION_SYMBOL);const long posMagic = PositionGetInteger(POSITION_MAGIC);if(posSymbol != _Symbol || !IsOwnDeal(posMagic))continue;posStatCount += 1;posStatLots += PositionGetDouble(POSITION_VOLUME);posStatProfit += PositionGetDouble(POSITION_PROFIT)+ PositionGetDouble(POSITION_SWAP);}}void UpdateStats(void){string statsInfo = StringFormat(\"\\n%s\\nBase Magic number: %d\\n\",robotTagline,Base_Magic_Number);if(entryProtectionMessage != \"\")statsInfo += \"\\n\" + entryProtectionMessage;if(Pos_Stat)statsInfo += GetPositionStats()+ \"\\n\";if(Robot_Stats)statsInfo += GetRobotStats()+ \"\\n\";if(Max_Spread > sigma || Max_OpenPos > sigma || Max_OpenLots > sigma || MaxDailyLoss > sigma || Max_Daily_DD > sigma || Min_Equity > sigma || Max_Equity > sigma || MaxEquity_DD > sigma)statsInfo += GetProtectionInfo();if(News_Priority != NewsFilter_Disabled)statsInfo += GetNewsText()+ \"\\n\";RenderStats(statsInfo);}string GetProtectionInfo(void){string protectionInfo = \"\\n ..:: Active Protections ::..\\n\";if(Max_Spread > sigma)protectionInfo += StringFormat(\"Max spread: %d,current: %d\\n\",Max_Spread,(int)MathRound((Ask()- Bid())/ _Point));if(Max_OpenPos > sigma)protectionInfo += StringFormat(\"Max open positions: %d,current: %d\\n\",Max_OpenPos,posStatCount);if(Max_OpenLots > sigma)protectionInfo += StringFormat(\"Max open lots: %.2f,current: %.2f\\n\",Max_OpenLots,posStatLots);if(MaxDailyLoss > sigma)protectionInfo += StringFormat(\"Max daily loss: %d,current: %.2f\\n\",MaxDailyLoss,dailyLoss);if(Max_Daily_DD > sigma)protectionInfo += StringFormat(\"Max daily drawdown: %.2f%%,current: %.2f%%\\n\",Max_Daily_DD,dailyDrawdown);if(Min_Equity > sigma)protectionInfo += StringFormat(\"Min equity: %d,current: %.2f\\n\",Min_Equity,AccountInfoDouble(ACCOUNT_EQUITY));if(MaxEquity_DD > sigma)protectionInfo += StringFormat(\"Max equity drawdown: %.2f%%,current: %.2f%%\\n\",MaxEquity_DD,equityDrawdownPercent);if(Max_Equity > sigma)protectionInfo += StringFormat(\"Max equity: %d,current: %.2f\\n\",Max_Equity,AccountInfoDouble(ACCOUNT_EQUITY));return protectionInfo;}string GetPositionStats(void){return \"\\n ..:: Positions Stats ::..\\n\" +(posStatCount > 0 ? StringFormat(\"Positions: %d,Lots: %.2f,Profit %.2f\",posStatCount,posStatLots,posStatProfit): \"Positions: no open position\");}string GetRobotStats(void){return \"\\n ..:: Trading Stats ::..\\n\" + \" 1-day: \" + GetRobotStatsDays(1)+ \"\\n\" + \" 7-day: \" + GetRobotStatsDays(7)+ \"\\n\" + \"30-day: \" + GetRobotStatsDays(30);}string GetRobotStatsDays(const int days){double grossProfit = 0;double grossLoss = 0;int histDealsCnt = 0;double histDealsProfit = 0;const datetime timeCurrent = TimeCurrent();const datetime timeStart = timeCurrent - days * PeriodSeconds(PERIOD_D1);HistorySelect(timeStart,timeCurrent);const int deals = HistoryDealsTotal();for(int i = 0;i < deals;i += 1){const ulong ticket = HistoryDealGetTicket(i);if(ticket == 0)continue;if(HistoryDealGetString(ticket,DEAL_SYMBOL)!= _Symbol)continue;const long dealMagic = HistoryDealGetInteger(ticket,DEAL_MAGIC);if(dealMagic > 0 && !IsOwnDeal(dealMagic))continue;const long dealType = HistoryDealGetInteger(ticket,DEAL_TYPE);if(dealType != DEAL_TYPE_BUY && dealType != DEAL_TYPE_SELL)continue;const long dealEntry = HistoryDealGetInteger(ticket,DEAL_ENTRY);if(dealEntry != DEAL_ENTRY_OUT)continue;const double profit = HistoryDealGetDouble(ticket,DEAL_PROFIT)+ HistoryDealGetDouble(ticket,DEAL_SWAP)+ HistoryDealGetDouble(ticket,DEAL_COMMISSION);histDealsProfit += profit;histDealsCnt += 1;if(profit > sigma)grossProfit += profit;if(profit < -sigma)grossLoss -= profit;}const double profitFactor = grossLoss > sigma ? grossProfit / grossLoss : grossProfit;return StringFormat(\"Trades: %d,Profit: %.2f,Profit factor: %.2f\",histDealsCnt,histDealsProfit,profitFactor);}string GetNewsInfo(void){return \"\";}void RenderStats(const string text){string lines[];const int linesCount = StringSplit(text,'\\n',lines);int lineWidth,lineHeight;TextGetSize(robotTagline,lineWidth,lineHeight);if(maxRectangles == 0)RectLabelCreate(0,\"Stats_background\",0,0,30,lineWidth,linesCount * lineHeight,GetChartBackColor(0));const color foreColor = GetChartForeColor(0);for(int i = 0;i < linesCount;i += 1){if(lines[i] == \"\")lines[i] = \" \";string labelName = \"label\" + IntegerToString(i);if(i < maxLabels)LabelUpdate(0,labelName,lines[i]);else LabelCreate(0,labelName,0,10,20 + i * lineHeight,CORNER_LEFT_UPPER,lines[i],\"Arial\",10,foreColor);int lnWidth,lnHeight;TextGetSize(lines[i],lnWidth,lnHeight);if(lnWidth > lineWidth)lineWidth = lnWidth;}ObjectSetInteger(0,\"Stats_background\",OBJPROP_XSIZE,(int)MathRound(lineWidth * 0.90));ObjectSetInteger(0,\"Stats_background\",OBJPROP_YSIZE,linesCount * lineHeight);for(int i = linesCount;i < maxLabels;i += 1)LabelUpdate(0,\"label\" + IntegerToString(i),\" \");}void RectLabelCreate(const long chartId = 0,const string name = \"RectLabel\",const int sub_window = 0,const int x = 0,const int y = 0,const int width = 50,const int height = 18,const color back_clr = clrBlack,const ENUM_BORDER_TYPE border = BORDER_SUNKEN,const ENUM_BASE_CORNER corner = CORNER_LEFT_UPPER,const color clr = clrBlack,const ENUM_LINE_STYLE style = STYLE_SOLID,const int line_width = 0,const bool back = false,const bool selection = false,const bool hidden = true,const long z_order = 0){if(!ObjectCreate(chartId,name,OBJ_RECTANGLE_LABEL,sub_window,0,0))return;maxRectangles += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_XSIZE,width);ObjectSetInteger(chartId,name,OBJPROP_YSIZE,height);ObjectSetInteger(chartId,name,OBJPROP_BGCOLOR,back_clr);ObjectSetInteger(chartId,name,OBJPROP_BORDER_TYPE,border);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_STYLE,style);ObjectSetInteger(chartId,name,OBJPROP_WIDTH,line_width);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelCreate(const long chartId=0,const string name=\"Label\",const int sub_window=0,const int x=0,const int y=0,const ENUM_BASE_CORNER corner=CORNER_LEFT_UPPER,const string text=\"Label\",const string font=\"Arial\",const int font_size=10,const color clr=clrYellow,const double angle=0.0,const ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER,const bool back=false,const bool selection=false,const bool hidden=true,const long z_order=0){if(!ObjectCreate(chartId,name,OBJ_LABEL,sub_window,0,0))return;maxLabels += 1;ObjectSetInteger(chartId,name,OBJPROP_XDISTANCE,x);ObjectSetInteger(chartId,name,OBJPROP_YDISTANCE,y);ObjectSetInteger(chartId,name,OBJPROP_CORNER,corner);ObjectSetString(chartId,name,OBJPROP_TEXT,text);ObjectSetString(chartId,name,OBJPROP_FONT,font);ObjectSetString(chartId,name,OBJPROP_TOOLTIP,\"\\n\");ObjectSetInteger(chartId,name,OBJPROP_FONTSIZE,font_size);ObjectSetDouble(chartId,name,OBJPROP_ANGLE,angle);ObjectSetInteger(chartId,name,OBJPROP_ANCHOR,anchor);ObjectSetInteger(chartId,name,OBJPROP_COLOR,clr);ObjectSetInteger(chartId,name,OBJPROP_BACK,back);ObjectSetInteger(chartId,name,OBJPROP_SELECTABLE,selection);ObjectSetInteger(chartId,name,OBJPROP_SELECTED,selection);ObjectSetInteger(chartId,name,OBJPROP_HIDDEN,hidden);ObjectSetInteger(chartId,name,OBJPROP_ZORDER,z_order);}void LabelUpdate(int chartId,string name,string text){ObjectSetString(chartId,name,OBJPROP_TEXT,text);}color GetChartForeColor(const long chartId=0){long foreColor = clrWhite;ChartGetInteger(chartId,CHART_COLOR_FOREGROUND,0,foreColor);return(color)foreColor;}color GetChartBackColor(const long chartId=0){long backColor = clrBlack;ChartGetInteger(chartId,CHART_COLOR_BACKGROUND,0,backColor);return(color)backColor;}void DeleteObjects(void){if(ObjectFind(0,\"Stats_background\")== 0)ObjectDelete(0,\"Stats_background\");maxLabels = MathMax(maxLabels,100);for(int i = 0;i < maxLabels;i++){const string objName = \"label\" + IntegerToString(i);if(ObjectFind(0,objName)== 0)ObjectDelete(0,objName);}maxRectangles = 0;maxLabels = 0;}void InitGlobalVariables(void){if(MQLInfoInteger(MQL_TESTER))return;const string accountNumberText =(string)AccountInfoInteger(ACCOUNT_LOGIN);accMaxEquityGlobalVarName = \"Max_Equity_\" + accountNumberText;accMaxDailyBalanceGlobalVarName = \"Max_Daily_Balance_\" + accountNumberText;accMaxDailyEquityGlobalVarName = \"Max_Daily_Equity_\" + accountNumberText;accEntrySuspendGlobalVarName = \"Is_Entry_Suspended_\" + accountNumberText;if(!GlobalVariableCheck(accMaxEquityGlobalVarName))GlobalVariableSet(accMaxEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accMaxDailyBalanceGlobalVarName))GlobalVariableSet(accMaxDailyBalanceGlobalVarName,AccountInfoDouble(ACCOUNT_BALANCE));if(!GlobalVariableCheck(accMaxDailyEquityGlobalVarName))GlobalVariableSet(accMaxDailyEquityGlobalVarName,AccountInfoDouble(ACCOUNT_EQUITY));if(!GlobalVariableCheck(accEntrySuspendGlobalVarName))GlobalVariableSet(accEntrySuspendGlobalVarName,0);}void LoadNews(void){loadNewsError = \"\";string error = \"\";const string newsContent = GetNewsContent(error);if(error != \"\"){loadNewsError = error;return;}if(newsContent == \"\"){loadNewsError = StringFormat(\"Cannot load news. Last error code: %d\",GetLastError());return;}ParseNewsContent(newsContent,error);if(error != \"\")loadNewsError = error;}void ParseNewsContent(const string newsContent,string &error){string lines[];const int linesLen = StringSplit(newsContent,'\\n',lines);if(linesLen == -1){error = \"Cannot parse the news feed\";return;}ArrayResize(newsRecords,linesLen);for(int i = 0;i < linesLen;i += 1){string fields[];const int fieldsLen = StringSplit(lines[i],';',fields);if(fieldsLen != 4){error = \"Cannot parse the news feed records\";return;}NewsRecord record;record.time =(datetime)StringToInteger(fields[0]);record.priority = fields[1];record.currency = fields[2];record.title = fields[3];newsRecords[i] = record;}}string GetNewsContent(string &error){const string url = \"https: char reqBody[],resData[];string headers;ResetLastError();const int resCode = WebRequest(\"GET\",url,\"\",10000,reqBody,resData,headers);const int resError = GetLastError();isNewsFeedOk = false;if(resError == ERR_FUNCTION_NOT_ALLOWED){error = \"News Filter cannot access the news server.\\n\" + \"Follow these steps to fix it:\\n\" \" - open the \\\"Tool\\\" -> \\\"Options\\\" panel\\n\" + \" - go to the \\\"Expert Advisors\\\" tab\\n\" + \" - enable the \\\"Allow WebRequest for the listed URL:\\\" option.\\n\" + \" - add \\\"https: return \"\";}if(resError != ERR_SUCCESS){error = StringFormat(\"News Filter connection error! Error code: %d\",resError);return \"\";}if(resCode != 200){error = StringFormat(\"Response code: %d\",resCode);return \"\";}isNewsFeedOk = true;return CharArrayToString(resData,0,ArraySize(resData),CP_UTF8);}string GetNewsText(void){string newsText = \"\\n ..:: Upcoming News ::..\\n\";if(loadNewsError != \"\")return newsText + loadNewsError;const datetime timeNow = TimeGMT();const datetime timeShift =(datetime)MathRound((TimeLocal()- timeNow)/ 3600.0)* 3600;const int newsCount = ArraySize(newsRecords);for(int i = 0,count = 0;i < newsCount && count < News_ViewCount;i += 1){const NewsRecord newsRecord = newsRecords[i];if(newsRecord.time < timeNow - News_AfterHigh * 60 || !NewsIsAcceptedCurrency(newsRecord)|| !NewsIsAcceptedPriority(newsRecord))continue;const string newLine = count > 0 ? \"\\n\" : \"\";const string newsTime = TimeToString(newsRecord.time + timeShift,TIME_DATE | TIME_MINUTES);const string priority = newsRecord.priority == \"high\" ? \"[high]\" : \"[med]\";const string text = StringFormat(\"%s%s %s %s %s\",newLine,priority,newsTime,newsRecord.currency,newsRecord.title);StringAdd(newsText,text);count += 1;}return newsText;}bool NewsIsAcceptedCurrency(const NewsRecord &newsRecord){for(int i = 0;i < ArraySize(newsCurrencies);i += 1)if(newsCurrencies[i] == newsRecord.currency)return true;return false;}bool NewsIsAcceptedPriority(const NewsRecord &newsRecord){return(News_Priority == NewsFilter_HighAndMedium)||(News_Priority == NewsFilter_HighOnly && newsRecord.priority == \"high\");}int NewsFilterActive(void){if(News_Priority == NewsFilter_Disabled)return -1;const datetime timeUtc = TimeGMT();const int newsLen = ArraySize(newsRecords);for(int i = 0;i < newsLen;i++){const NewsRecord news = newsRecords[i];if(!NewsIsAcceptedCurrency(news)|| !NewsIsAcceptedPriority(news))continue;if(news.priority == \"high\" && news.time - News_BeforeHigh * 60 - 15 <= timeUtc && news.time + News_AfterHigh * 60 - 15 >= timeUtc)return i;if(news.priority == \"medium\" && news.time - News_BeforeMedium * 60 - 15 <= timeUtc && news.time + News_AfterMedium * 60 - 15 >= timeUtc)return i;}return -1;}void ParseNewsCurrenciesText(void){string parts[],parsed[];const int partsLen = StringSplit(News_Currencies,',',parts);ArrayResize(parsed,partsLen);int len = 0;for(int i = 0;i < partsLen;i += 1){string part = parts[i];StringReplace(part,\" \",\"\");if(StringLen(part)> 0){parsed[i] = part;len += 1;}}ArrayResize(newsCurrencies,len);for(int i = 0;i < len;i += 1)newsCurrencies[i] = parsed[i];}int GetMagicNumber(const int strategyIndex){return 1000 * Base_Magic_Number + strategyIndex;}bool IsOwnDeal(const long dealMagic){const long minMagicNumber = GetMagicNumber(0);const long maxMagicNumber = GetMagicNumber(strategiesCount);return dealMagic >= minMagicNumber && dealMagic < maxMagicNumber;}int OrderDirectionToCommand(OrderDirection dir){return dir == ORDER_DIRECTION_BUY ? OP_BUY : dir == ORDER_DIRECTION_SELL ? OP_SELL : OP_FLAT;}void InitIndicatorHandlers(void){TesterHideIndicators(true);indHandlers[0][0][0] = iBands(NULL,0,22,0,3.33,PRICE_CLOSE);indHandlers[0][1][0] = iRVI(NULL,0,60);indHandlers[0][2][0] = iATR(NULL,0,32);indHandlers[1][0][0] = iMA(NULL,0,3,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][0][1] = iMA(NULL,0,17,0,MODE_SMA,PRICE_CLOSE);indHandlers[1][1][0] = iForce(NULL,0,10,MODE_SMA,VOLUME_TICK);indHandlers[1][2][0] = iDeMarker(NULL,0,39);indHandlers[1][3][0] = iAlligator(NULL,0,39,18,18,3,3,12,MODE_SMMA,PRICE_MEDIAN);indHandlers[1][4][0] = iATR(NULL,0,38);indHandlers[1][5][0] = -1;indHandlers[2][0][0] = iAO(NULL,0);indHandlers[2][1][0] = iDeMarker(NULL,0,39);indHandlers[2][2][0] = -1;indHandlers[3][0][0] = iADX(NULL,0,65);indHandlers[3][1][0] = iStochastic(NULL,0,20,9,9,MODE_SMA,0);indHandlers[3][2][0] = iBearsPower(NULL,0,60);indHandlers[4][0][0] = -1;indHandlers[4][1][0] = iRVI(NULL,0,46);indHandlers[4][2][0] = iAD(NULL,0,VOLUME_TICK);indHandlers[4][3][0] = iMACD(NULL,0,12,24,9,PRICE_CLOSE);indHandlers[4][4][0] = -1;TesterHideIndicators(false);}void SetSignals(Signal &signalList[]){int i = 0;ArrayResize(signalList,2 * strategiesCount);/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_000();signalList[i++] = GetEntrySignal_000();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_001();signalList[i++] = GetEntrySignal_001();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_002();signalList[i++] = GetEntrySignal_002();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_003();signalList[i++] = GetEntrySignal_003();/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":85,\"takeProfit\":104,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Long or Short\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[46,-0.06,0,0,0,0]},{\"name\":\"Accumulation Distribution\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]},{\"name\":\"MACD\",\"listIndexes\":[1,3,0,0,0],\"numValues\":[12,24,9,0,0,0]}],\"closeFilters\":[{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[8,26,0,0,0,0]}]}*/ signalList[i++] = GetExitSignal_004();signalList[i++] = GetEntrySignal_004();if(i != 2 * strategiesCount)ArrayResize(signalList,i);}Signal GetEntrySignal_000(){double ind0buffer0[];CopyBuffer(indHandlers[0][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[0][0][0],2,1,2,ind0buffer1);double ind0upBand1 = ind0buffer0[1];double ind0dnBand1 = ind0buffer1[1];double ind0upBand2 = ind0buffer0[0];double ind0dnBand2 = ind0buffer1[0];bool ind0long = Open(0)< ind0dnBand1 - sigma && Open(1)> ind0dnBand2 + sigma;bool ind0short = Open(0)> ind0upBand1 + sigma && Open(1)< ind0upBand2 - sigma;double ind1buffer[];CopyBuffer(indHandlers[0][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < ind1val2 - sigma;bool ind1short = ind1val1 > ind1val2 + sigma;return CreateEntrySignal(0,ind0long && ind1long,ind0short && ind1short,265,227,true,true);}Signal GetExitSignal_000(){double ind2buffer[];CopyBuffer(indHandlers[0][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > 0.0087 + sigma && ind2val2 < 0.0087 - sigma;bool ind2short = ind2long;return CreateExitSignal(0,ind2long,ind2short,265,227,true);}Signal GetEntrySignal_001(){double ind0buffer0[];CopyBuffer(indHandlers[1][0][0],0,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[1][0][1],0,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];bool ind0long = ind0val1 < ind0val2 - sigma;bool ind0short = ind0val1 > ind0val2 + sigma;double ind1buffer[];CopyBuffer(indHandlers[1][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];bool ind1long = ind1val1 < 0 - sigma;bool ind1short = ind1val1 > 0 + sigma;double ind2buffer[];CopyBuffer(indHandlers[1][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer0[];CopyBuffer(indHandlers[1][3][0],0,1,2,ind3buffer0);double ind3buffer1[];CopyBuffer(indHandlers[1][3][0],1,1,2,ind3buffer1);double ind3buffer2[];CopyBuffer(indHandlers[1][3][0],2,1,2,ind3buffer2);double ind3val1 = ind3buffer2[1];double ind3val2 = ind3buffer0[1];double ind3val3 = ind3buffer2[0];double ind3val4 = ind3buffer0[0];bool ind3long = ind3val1 > ind3val2 + sigma && ind3val3 < ind3val4 - sigma;bool ind3short = ind3val1 < ind3val2 - sigma && ind3val3 > ind3val4 + sigma;return CreateEntrySignal(1,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,350,275,true,true);}Signal GetExitSignal_001(){double ind4buffer[];CopyBuffer(indHandlers[1][4][0],0,1,3,ind4buffer);double ind4val1 = ind4buffer[2];bool ind4long = ind4val1 > 0.0038 + sigma;bool ind4short = ind4long;bool ind5long = false;bool ind5short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 5 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 34 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 34 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind5long = isBullishPinBar;ind5short = isBearishPinBar;}return CreateExitSignal(1,ind4long || ind5long,ind4short || ind5short,350,275,true);}Signal GetEntrySignal_002(){double ind0buffer[];CopyBuffer(indHandlers[2][0][0],0,1,3,ind0buffer);double ind0val1 = ind0buffer[2];double ind0val2 = ind0buffer[1];bool ind0long = ind0val1 < -0.0005 - sigma && ind0val2 > -0.0005 + sigma;bool ind0short = ind0val1 > 0.0005 + sigma && ind0val2 < 0.0005 - sigma;double ind1buffer[];CopyBuffer(indHandlers[2][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 0.44 - sigma && ind1val2 > 0.44 + sigma;bool ind1short = ind1val1 > 1 - 0.44 + sigma && ind1val2 < 1 - 0.44 - sigma;return CreateEntrySignal(2,ind0long && ind1long,ind0short && ind1short,189,78,true,true);}Signal GetExitSignal_002(){bool ind2long = false;bool ind2short = false;return CreateExitSignal(2,ind2long,ind2short,189,78,true);}Signal GetEntrySignal_003(){double ind0buffer0[];CopyBuffer(indHandlers[3][0][0],1,1,2,ind0buffer0);double ind0buffer1[];CopyBuffer(indHandlers[3][0][0],2,1,2,ind0buffer1);double ind0val1 = ind0buffer0[1];double ind0val2 = ind0buffer1[1];double ind0val3 = ind0buffer0[0];double ind0val4 = ind0buffer1[0];bool ind0long = ind0val1 < ind0val2 - sigma && ind0val3 > ind0val4 + sigma;bool ind0short = ind0val1 > ind0val2 + sigma && ind0val3 < ind0val4 - sigma;double ind1buffer[];CopyBuffer(indHandlers[3][1][0],MAIN_LINE,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < 57.9 - sigma && ind1val2 > 57.9 + sigma;bool ind1short = ind1val1 > 100 - 57.9 + sigma && ind1val2 < 100 - 57.9 - sigma;return CreateEntrySignal(3,ind0long && ind1long,ind0short && ind1short,364,445,false,true);}Signal GetExitSignal_003(){double ind2buffer[];CopyBuffer(indHandlers[3][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];bool ind2long = ind2val1 > 0.0078 + sigma;bool ind2short = ind2val1 < -0.0078 - sigma;return CreateExitSignal(3,ind2long,ind2short,364,445,false);}Signal GetEntrySignal_004(){bool ind0long = true;bool ind0short = false;double ind1buffer[];CopyBuffer(indHandlers[4][1][0],0,1,3,ind1buffer);double ind1val1 = ind1buffer[2];double ind1val2 = ind1buffer[1];bool ind1long = ind1val1 < -0.06 - sigma && ind1val2 > -0.06 + sigma;bool ind1short = ind1val1 > 0.06 + sigma && ind1val2 < 0.06 - sigma;double ind2buffer[];CopyBuffer(indHandlers[4][2][0],0,1,3,ind2buffer);double ind2val1 = ind2buffer[2];double ind2val2 = ind2buffer[1];bool ind2long = ind2val1 > ind2val2 + sigma;bool ind2short = ind2val1 < ind2val2 - sigma;double ind3buffer[];CopyBuffer(indHandlers[4][3][0],0,1,3,ind3buffer);double ind3val1 = ind3buffer[2];double ind3val2 = ind3buffer[1];bool ind3long = ind3val1 < ind3val2 - sigma;bool ind3short = ind3val1 > ind3val2 + sigma;return CreateEntrySignal(4,ind0long && ind1long && ind2long && ind3long,ind0short && ind1short && ind2short && ind3short,85,104,false,true);}Signal GetExitSignal_004(){bool ind4long = false;bool ind4short = false;{double closeOpen = MathAbs(Close(1)- Open(1));bool isPinBar = closeOpen < 8 * 0.01 *(High(1)- Low(1));bool upWick = High(1)- MathMax(Close(1),Open(1))> 26 * 0.01 * closeOpen;bool downWick = MathMin(Close(1),Open(1))- Low(1)> 26 * 0.01 * closeOpen;bool isBearishPinBar = isPinBar && upWick && !downWick;bool isBullishPinBar = isPinBar && downWick && !upWick;ind4long = isBullishPinBar;ind4short = isBearishPinBar;}return CreateExitSignal(4,ind4long,ind4short,85,104,false);}/*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":265,\"takeProfit\":227,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Bollinger Bands\",\"listIndexes\":[4,3,0,0,0],\"numValues\":[22,3.33,0,0,0,0]},{\"name\":\"RVI\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[60,0,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[4,0,0,0,0],\"numValues\":[32,0.0087,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":350,\"takeProfit\":275,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Moving Averages Crossover\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[3,17,0,0,0,0]},{\"name\":\"Force Index\",\"listIndexes\":[3,0,0,0,0],\"numValues\":[10,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[39,0,0,0,0,0]},{\"name\":\"Alligator\",\"listIndexes\":[8,3,4,0,0],\"numValues\":[39,18,18,3,3,12]}],\"closeFilters\":[{\"name\":\"Average True Range\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[38,0.0038,0,0,0,0]},{\"name\":\"Pin Bar\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[5,34,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":189,\"takeProfit\":78,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":true},\"openFilters\":[{\"name\":\"Awesome Oscillator\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[-0.0005,0,0,0,0,0]},{\"name\":\"DeMarker\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[39,0.44,0,0,0,0]}],\"closeFilters\":[{\"name\":\"Do not Exit\",\"listIndexes\":[0,0,0,0,0],\"numValues\":[0,0,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal\":1,\"stopLoss\":364,\"takeProfit\":445,\"useStopLoss\":true,\"useTakeProfit\":true,\"isTrailingStop\":false},\"openFilters\":[{\"name\":\"Directional Indicators\",\"listIndexes\":[1,0,0,0,0],\"numValues\":[65,0,0,0,0,0]},{\"name\":\"Stochastic\",\"listIndexes\":[5,0,0,0,0],\"numValues\":[20,9,9,57.9,0,0]}],\"closeFilters\":[{\"name\":\"Bears Power\",\"listIndexes\":[2,0,0,0,0],\"numValues\":[60,0.0078,0,0,0,0]}]}*/ /*STRATEGY CODE{\"properties\":{\"entryLots\":0.01,\"tradeDirectionMode\":0,\"oppositeEntrySignal"
        ],
        "direction": "both",
        "indicators_used": [
          "Moving Average",
          "MACD",
          "Bollinger Bands",
          "Stochastic",
          "ADX",
          "ATR",
          "DeMarker",
          "RVI",
          "Awesome Oscillator",
          "Force Index",
          "Bears Power",
          "Alligator",
          "Simple Moving Average",
          "Accelerator"
        ],
        "line_number": 1,
        "type": "exit"
      }
    ]
  },
  "created_at": "2025-07-08T19:03:23.740446",
  "status": "inactive",
  "source": "code_import",
  "id": "82000cc4"
}